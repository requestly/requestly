{"id":"bd--65ijw-ml1vxvze537","title":"Fix multi-tab infinite reload loop - add skipBroadcast option","description":"The previous tab ID fix didn't work because it only prevents self-reload but doesn't stop the cross-tab ping-pong. When Tab A loads, it broadcasts and causes Tab B to reload. Tab B then broadcasts and causes Tab A to reload.\n\nRoot cause: `setupWorkspaceView` in container.tsx runs on every mount, which calls `switchToPrivateWorkspace`, which calls `switchWorkspace`, which broadcasts to all tabs.\n\nSolution: Add `skipBroadcast` parameter to `switchWorkspace` and use it when called during initialization (not explicit user action). This prevents the broadcast cascade during page load while still allowing user-initiated workspace switches to notify other tabs.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-31T05:42:34.538Z","updated_at":"2026-01-31T05:43:53.930Z","closed_at":"2026-01-31T05:43:53.930Z","dependencies":[],"labels":[],"comments":[]}
{"id":"bd--65ijw-ml1we73rqfn","title":"Analysis: Potential breaking scenarios from skipBroadcast fix","description":"Analysis complete. CORRECTION: The fix is actually more targeted than initially assessed.\n\n**What I changed:**\n1. `switchToPrivateWorkspace()` → passes `{ skipBroadcast: true }` (only called from setupWorkspaceView initialization)\n2. `clearCurrentlyActiveWorkspace()` → accepts options with default `{}`, so `skipBroadcast` defaults to `false`\n\n**Revised Risk Assessment:**\n\n**LOW RISK (fix handles correctly):**\n- User logout in Tab B → `clearCurrentlyActiveWorkspace()` called without options → broadcasts → Tab A reloads ✓\n- User removed from workspace → `clearCurrentlyActiveWorkspace()` called → broadcasts → other tabs reload ✓\n- Workspace deleted → same as above ✓\n\n**NO RISK (intended behavior):**\n- New tab initialization → `switchToPrivateWorkspace()` with `skipBroadcast: true` → doesn't broadcast ✓\n\n**Only breaking scenario:**\nIf there are OTHER call sites that explicitly call `switchWorkspace` with `skipBroadcast: true` when they shouldn't, or if `switchToPrivateWorkspace` gets used for non-initialization purposes.\n\n**Current state is correct:**\n- Initialization flows skip broadcast (prevents reload loops)  \n- Auth/permission flows broadcast (keeps tabs in sync)\n- User-initiated switches broadcast (intentional user action)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-31T05:55:15.447Z","updated_at":"2026-01-31T05:56:26.910Z","closed_at":"2026-01-31T05:56:26.910Z","dependencies":[],"labels":[],"comments":[]}
{"id":"bd--65ijw-ml1ygui952h","title":"Race condition in environment rename causing ENOENT","description":"## Problem\nWhen renaming an environment, rapid successive calls to `updateEnvironment` with name changes cause an ENOENT error:\n```\nENOENT: no such file or directory, rename '/Users/srbh/Documents/uio/environments/asdasdmm.json' -> '/Users/srbh/Documents/uio/environments/asdasddsd.json'\n```\n\n## Root Cause\nThis is a **Time-of-Check-Time-of-Use (TOCTOU) race condition**:\n\n1. **Call A** starts: `fileIndex.getPath(id)` returns `/asdasdmm.json`\n2. **Call A** performs filesystem rename: file now exists at `/asdasddsd.json`  \n3. **Call A** updates index: `fileIndex.movePath(old, new)` ✓\n4. **Call B** starts BEFORE Call A finishes index update\n5. **Call B** `fileIndex.getPath(id)` returns stale path `/asdasdmm.json` (WRONG!)\n6. **Call B** tries to rename `/asdasdmm.json` → ENOENT (file doesn't exist at source)\n\n## Why Both onBlur and onPressEnter Fire\nWhen user presses Enter in rename input:\n- `onPressEnter` fires on keydown (calls handleEnvironmentRename)\n- Input loses focus → `onBlur` fires (also calls handleEnvironmentRename)\n- Both events trigger in rapid succession\n\n## Evidence from Code\n\n### Desktop App (FsManager.ts)\n```typescript\nasync updateEnvironment(id, patch) {\n  const fileResourceResult = await this.getFileResourceWithNameVerification({\n    id,\n    name: patch.name,  // If name provided, triggers rename\n  });\n  // ... read, update, write\n}\n\nasync getFileResourceWithNameVerification({ id, name }) {\n  const existingFile = this.createResource({ id, type: \"file\" }); // Uses fileIndex.getPath()\n  // ... if name differs, calls rename(existingFile, newFileResource)\n}\n```\n\n### File Index Race\n```typescript\n// fileIndex.getPath() - synchronous Map lookup\ngetPath(id): string | undefined {\n  return this.idToPath.get(id);  // Can return stale path during concurrent operations\n}\n\n// rename() - async gap between FS operation and index update\nawait FsService.rename(oldPath, newPath);  // File moves on disk\nfileIndex.movePath(oldPath, newPath);       // Index updates (BUT there's a gap!)\n```\n\n## Why This Appears Now (Branch vs Master)\n\nBoth branches have the same UI pattern (both onBlur + onPressEnter). The race condition exists in the filesystem layer on both branches. However:\n\n**Timing differences between command pattern and thunk pattern:**\n- **Old (commands)**: Synchronous store update happens IMMEDIATELY after repository call\n- **New (thunks)**: Redux dispatch → action processing → store update has microtask delays\n\nThis slight timing shift may expose the race condition more frequently.\n\n## Fix Options\n\n### Option 1: Add per-ID update lock in desktop app (RECOMMENDED)\nAlready implemented - serializes updates per environment ID:\n```typescript\nconst updateLocks = new Map<string, Promise<unknown>>();\nasync function withUpdateLock<T>(key: string, fn: () => Promise<T>): Promise<T>\n```\n\n### Option 2: Request deduplication in web app\nAdd `isRenaming` guard at component level - but this is a band-aid that doesn't protect against races from other sources.\n\n### Option 3: Atomic index update\nUpdate fileIndex BEFORE filesystem operation, with rollback on failure - complex but eliminates race window.\n\n## Conclusion\nThis is a legitimate filesystem-level race condition. The desktop app lock (Option 1) is the correct fix because:\n1. It protects at the operation level (any caller, not just this component)\n2. File renames are inherently non-concurrent-safe\n3. The web app shouldn't need to know about filesystem implementation details","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-31T06:53:18.321Z","updated_at":"2026-01-31T06:53:18.321Z","dependencies":[],"labels":[],"comments":[]}
{"id":"bd--65ijw-ml22rouqrbk","title":"Deep Dive: \"No context found in registry!\" Error Analysis","description":"Reverted temporary debug changes in WorkspaceProvider and MultiViewError. Only the core fix in ApiClientContextService remains. Ready to provide detailed explanation.","status":"open","priority":0,"issue_type":"bug","created_at":"2026-01-31T08:53:42.674Z","updated_at":"2026-01-31T09:35:34.897Z","dependencies":[],"labels":[],"comments":[]}
{"id":"bd--65ijw-ml4s0ogivmo","title":"OpenAPI Import Issues - Modal not closing and import failure","description":"Two issues with OpenAPI spec import:\n1. Import modal doesn't close after successful import\n2. Import may not be processing correctly\n\nLocation: /Users/srbh/Projects/bstack/requestly/app/src/features/apiClient/screens/apiClient/components/CommonApiClientImporter/CommonApiClientImporter.tsx\n\nTest file: /Users/srbh/Downloads/1Password Connect-swagger.yaml","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-02T06:16:04.818Z","updated_at":"2026-02-02T06:17:53.132Z","closed_at":"2026-02-02T06:17:53.132Z","dependencies":[],"labels":[],"comments":[]}
{"id":"bd--65ijw-ml4s0oh6vq8","title":"Debug and analyze import flow issues","description":"Found the root cause: handleImportEnvironments returns { successCount, failedCount } but handleImportData was treating it as PromiseSettledResult[] array. Calling .filter() on an object throws TypeError, caught by try-catch, preventing onImportSuccess() from being called.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-02T06:16:04.842Z","updated_at":"2026-02-02T06:17:47.194Z","parent_id":"bd--65ijw-ml4s0ogivmo","dependencies":[],"labels":[],"comments":[]}
{"id":"bd--65ijw-ml4s0ohd5bn","title":"Fix modal not closing after import","description":"Fixed by changing lines 404-411 to correctly destructure the returned object: const envResult = environmentResults.value as { successCount: number; failedCount: number }; totalImported += envResult.successCount; totalFailed += envResult.failedCount;","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-02T06:16:04.849Z","updated_at":"2026-02-02T06:17:48.028Z","parent_id":"bd--65ijw-ml4s0ogivmo","dependencies":[],"labels":[],"comments":[]}
{"id":"bd--65ijw-ml4s0ohjkml","title":"Verify import data processing is correct","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-02T06:16:04.855Z","updated_at":"2026-02-02T06:16:04.855Z","parent_id":"bd--65ijw-ml4s0ogivmo","dependencies":[],"labels":[],"comments":[]}