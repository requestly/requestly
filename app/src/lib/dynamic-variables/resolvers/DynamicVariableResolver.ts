import type { DynamicVariable, VariableContext } from "../types";
import type { DynamicVariableProvider } from "../providers/DynamicVariableProvider";

/**
 * Abstract base class for dynamic variable resolvers.
 *
 * Responsible for:
 * 1. Taking a template string with dynamic variable placeholders (e.g., "{{$randomEmail}}")
 * 2. Replacing those placeholders with generated values
 * 3. Respecting variable priority (user-defined variables take precedence)
 *
 * The resolver pattern separates the "what" (provider defines variables) from
 * the "how" (resolver defines the replacement strategy):
 *
 * - HandlebarsResolver: Uses Handlebars templating engine for {{$var}} syntax
 * - Future resolvers: Could use regex-based replacement, custom parsers, etc.
 *
 * Why this abstraction?
 * - Different contexts may need different replacement strategies
 * - Handlebars provides argument support ({{$randomInt 1 100}}) out of the box
 * - Easy to swap implementations without changing provider logic
 * - Testable: Can create mock resolvers for unit tests
 *
 * Variable Priority:
 * Resolvers should respect this priority order (highest to lowest):
 * 1. User-defined variables (environment, collection, global)
 * 2. Dynamic variables (generated by provider)
 *
 * This ensures that if a user defines a variable named "$randomEmail" in their
 * environment, their value is used instead of generating a random one.
 *
 * @example
 * ```typescript
 * const resolver = new HandlebarsResolver(fakerProvider);
 *
 * // Without context - uses dynamic variable
 * resolver.resolve("{{$randomEmail}}"); // → "john.doe@example.com"
 *
 * // With context - user variable takes priority
 * resolver.resolve("{{$randomEmail}}", { "$randomEmail": "custom@test.com" });
 * // → "custom@test.com"
 * ```
 */
export abstract class DynamicVariableResolver {
  /**
   * Create a resolver with the specified provider.
   *
   * @param provider - The provider that supplies dynamic variable definitions
   */
  constructor(protected provider: DynamicVariableProvider) {}

  getVariable(name: string): DynamicVariable | undefined {
    return this.provider.getVariable(name);
  }

  has(name: string): boolean {
    return this.provider.has(name);
  }

  listAll(): DynamicVariable[] {
    return this.provider.list();
  }

  /**
   * Resolve all dynamic variables in a template string.
   *
   * @param template - Template string with {{$variableName}} placeholders
   * @param context - Optional user-defined variables that take priority over dynamic ones
   * @returns The resolved string with all placeholders replaced
   */
  abstract resolve(template: string, context?: VariableContext): string;
}
