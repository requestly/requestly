import { create } from "zustand";
import { RequestContentType, RQAPI } from "../types";
import { extractAuthHeadersAndParams } from "../helpers/auth";
export type SimpleKeyValuePair = { key: string; value: string };
export enum AutogeneratedFieldsNamespace {
  AUTH = "auth",
  CONTENT_TYPE = "content_type",
}

interface NamespaceContents {
  queryParams: SimpleKeyValuePair[];
  headers: Map<string, string>;
}

export interface AutogeneratedFieldsStore {
  namespaces: Partial<Record<AutogeneratedFieldsNamespace, NamespaceContents>>;
  headerVersion: number;
  queryParamsVersion: number;

  //Header methods
  initialize: <T extends RQAPI.Entry>(input: T, resolver: <U extends Record<string, any>>(input: U) => U) => void;
  _addHeaders: (namespace: AutogeneratedFieldsNamespace, params: Record<string, string>) => void;
  _removeHeaders: (namespace: AutogeneratedFieldsNamespace, key: string) => void;
  clearNamespace: (namespace: AutogeneratedFieldsNamespace, skipVersionUpdate?: boolean) => void;
  purgeAndAddHeaders: (namespace: AutogeneratedFieldsNamespace, params: Record<string, string>) => void;
  getAllHeaders: () => SimpleKeyValuePair[];
  getAllQueryParams: () => SimpleKeyValuePair[];
  _addQueryparams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => void;
  purgeAndAddQueryParams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => void;
  purgeAndAdd: (
    namespace: AutogeneratedFieldsNamespace,
    headers: Record<string, string>,
    queryParams: SimpleKeyValuePair[]
  ) => void;
}
export function parseAuth(
  auth: RQAPI.Auth,
  resolver?: <U extends Record<string, any>>(input: U) => U
): NamespaceContents {
  // extract the auth from config & push them in header map
  // handle how i will store the key value pair here
  // ---> now here we can use that function already defined since it has the same signature of params
  const { headers, queryParams } = extractAuthHeadersAndParams(resolver ? resolver(auth) : auth);
  //convert the headers from KP to map
  const headersMap = new Map<string, string>();
  headers.forEach(({ key, value }) => {
    headersMap.set(key, value);
  });

  const queryParamsContent: SimpleKeyValuePair[] = [];
  queryParams.forEach(({ key, value }) => {
    queryParamsContent.push({ key, value });
  });

  return {
    queryParams: queryParamsContent,
    headers: headersMap,
  };
}
export function parseContentType(contentType: RequestContentType): NamespaceContents {
  const queryParams: SimpleKeyValuePair[] = [];
  const headersMap = new Map<string, string>();
  headersMap.set("content-type", contentType);
  return {
    queryParams,
    headers: headersMap,
  };
}
function parseRequestEntry(entry?: RQAPI.Entry): AutogeneratedFieldsStore["namespaces"] {
  const result: AutogeneratedFieldsStore["namespaces"] = {};
  if (!entry) {
    return result;
  }

  // we have to return the final namespaces structure that is intialized here
  // from the entry itself we will fetch the auth & corresponding value for headers will be taken out & added to the headers
  const { auth } = entry;
  const authNamespaceContents = parseAuth(auth);
  result.auth = authNamespaceContents;
  const contentType = entry.request.contentType;
  if (contentType) {
    result.content_type = parseContentType(entry.request.contentType);
  }

  return result;
}

export const createAutogeneratedStore = (entry?: RQAPI.Entry) => {
  return create<AutogeneratedFieldsStore>()((set, get) => ({
    namespaces: {},
    headerVersion: 0,
    queryParamsVersion: 0,

    initialize: <T extends RQAPI.Entry>(entry: T, resolver: <U extends Record<string, any>>(input: U) => U) => {
      // it accepts an entry & returns an entry -> so types would be like that
      const result = resolver(entry);
      const namespaces = parseRequestEntry(result);
      set({
        namespaces,
      });
    },

    _addHeaders: (namespace: AutogeneratedFieldsNamespace, params: Record<string, string>) => {
      const { headerVersion, namespaces } = get();
      const updatedHeaders = new Map<string, string>();

      Object.entries(params).forEach(([key, value]) => {
        updatedHeaders.set(key, value);
      });

      const updatedState = {
        namespaces: {
          ...namespaces,
          [namespace]: {
            ...namespaces[namespace],
            headers: updatedHeaders,
          },
        },
        headerVersion: headerVersion + 1,
      };
      set(updatedState);
    },

    _removeHeaders: (namespace: AutogeneratedFieldsNamespace, key: string) => {
      //set(namespace, key);
    },
    clearNamespace: (namespace: AutogeneratedFieldsNamespace, skipVersionUpdate = false) => {
      // logic to clear all the namespace
      let { headerVersion, queryParamsVersion, namespaces } = get();
      namespaces[namespace] = {
        headers: new Map(),
        queryParams: [],
      };
      if (!skipVersionUpdate) {
        headerVersion++;
        queryParamsVersion++;
      }
      set({
        namespaces,
        headerVersion,
        queryParamsVersion,
      });
    },
    purgeAndAddHeaders: (namespace: AutogeneratedFieldsNamespace, params: Record<string, string>) => {
      const { clearNamespace, _addHeaders } = get();
      clearNamespace(namespace, true);
      _addHeaders(namespace, params);
    },

    _addQueryparams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => {
      const { queryParamsVersion, namespaces } = get();

      const updatedState = {
        namespaces: {
          ...namespaces,
          [namespace]: {
            ...namespaces[namespace],
            queryParams: params,
          },
        },
        queryParamsVersion: queryParamsVersion + 1,
      };
      set(updatedState);
    },

    purgeAndAddQueryParams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => {
      const { clearNamespace, _addQueryparams } = get();
      clearNamespace(namespace, true);
      _addQueryparams(namespace, params);
    },

    purgeAndAdd: (
      namespace: AutogeneratedFieldsNamespace,
      headers: Record<string, string>,
      queryParams: SimpleKeyValuePair[]
    ) => {
      const { clearNamespace, _addQueryparams, _addHeaders } = get();

      clearNamespace(namespace, true);
      _addHeaders(namespace, headers);
      _addQueryparams(namespace, queryParams);
    },

    getAllHeaders() {
      const result: SimpleKeyValuePair[] = [];
      const { namespaces } = get();
      for (const namespace in namespaces) {
        const { headers } = namespaces[namespace as AutogeneratedFieldsNamespace];
        for (const headerEntry of headers.entries()) {
          const [key, value] = headerEntry;
          result.push({
            key,
            value,
          });
        }
      }
      return result;
    },

    getAllQueryParams() {
      const result: SimpleKeyValuePair[] = [];
      const { namespaces } = get();
      for (const namespace in namespaces) {
        const { queryParams } = namespaces[namespace as AutogeneratedFieldsNamespace];
        for (const queryParam of queryParams) {
          result.push({
            key: queryParam.key,
            value: queryParam.value,
          });
        }
      }
      return result;
    },
  }));
};
