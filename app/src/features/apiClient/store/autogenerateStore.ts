import { create } from "zustand";
import { RequestContentType, RQAPI } from "../types";
import { extractAuthHeadersAndParams } from "../helpers/auth";
export type SimpleKeyValuePair = { key: string; value: string };
export enum AutogeneratedFieldsNamespace {
  AUTH = "auth",
  CONTENT_TYPE = "content_type",
}
export const MULTIPART_FORM_PRETTY_VALUE = "multipart/form-data boundary<calculated at runtime>";
interface NamespaceContents {
  queryParams: SimpleKeyValuePair[];
  headers: Map<string, { value: string; prettyValue?: string }>;
}

export interface AutogeneratedFieldsStore {
  namespaces: Partial<Record<AutogeneratedFieldsNamespace, NamespaceContents>>;
  headerVersion: number;
  queryParamsVersion: number;

  //Header methods
  initialize: (namespaces: AutogeneratedFieldsStore["namespaces"]) => void;
  _addHeaders: (
    namespace: AutogeneratedFieldsNamespace,
    params: Record<string, { value: string; prettyValue?: string }>
  ) => void;
  clearNamespace: (namespace: AutogeneratedFieldsNamespace, skipVersionUpdate?: boolean) => void;
  purgeAndAddHeaders: (
    namespace: AutogeneratedFieldsNamespace,
    params: Record<string, { value: string; prettyValue?: string }>
  ) => void;
  getHeadersToShow: () => SimpleKeyValuePair[];
  getHeadersOnPrepareRequest: () => SimpleKeyValuePair[];
  getAllQueryParams: () => SimpleKeyValuePair[];
  _addQueryparams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => void;
  purgeAndAddQueryParams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => void;
  purgeAndAdd: (
    namespace: AutogeneratedFieldsNamespace,
    headers: Record<string, { value: string; prettyValue?: string }>,
    queryParams: SimpleKeyValuePair[]
  ) => void;
}
export function parseAuth(
  auth: RQAPI.Auth,
  resolver?: <U extends Record<string, any>>(input: U) => U
): NamespaceContents {
  // extract the auth from config & push them in header map
  // handle how i will store the key value pair here
  // ---> now here we can use that function already defined since it has the same signature of params
  const { headers, queryParams } = extractAuthHeadersAndParams(resolver ? resolver(auth) : auth);
  //convert the headers from KP to map
  const headersMap = new Map<string, { value: string; prettyValue?: string }>();
  headers.forEach(({ key, value }) => {
    headersMap.set(key, { value });
  });

  const queryParamsContent: SimpleKeyValuePair[] = [];
  queryParams.forEach(({ key, value }) => {
    queryParamsContent.push({ key, value });
  });

  return {
    queryParams: queryParamsContent,
    headers: headersMap,
  };
}

export function parseContentType(contentType: RequestContentType): NamespaceContents {
  const queryParams: SimpleKeyValuePair[] = [];
  const headersMap = new Map<string, { value: string; prettyValue?: string }>();

  const addprettyValue = contentType === RequestContentType.multiPartForm ? MULTIPART_FORM_PRETTY_VALUE : undefined;

  headersMap.set("content-type", { value: contentType, prettyValue: addprettyValue });
  return {
    queryParams,
    headers: headersMap,
  };
}

function collectHeaders(
  namespaces: AutogeneratedFieldsStore["namespaces"],
  valueSelector: (value: { value: string; prettyValue?: string }) => string
): SimpleKeyValuePair[] {
  const result: SimpleKeyValuePair[] = [];

  for (const namespace in namespaces) {
    const { headers } = namespaces[namespace as AutogeneratedFieldsNamespace];
    for (const headerEntry of headers.entries()) {
      const [key, value] = headerEntry;
      result.push({
        key,
        value: valueSelector(value),
      });
    }
  }
  return result;
}

export const createAutogeneratedStore = () => {
  return create<AutogeneratedFieldsStore>()((set, get) => ({
    namespaces: {},
    headerVersion: 0,
    queryParamsVersion: 0,

    initialize: (namespaces: AutogeneratedFieldsStore["namespaces"]) => {
      set((state) => ({
        namespaces,
        headerVersion: state.headerVersion + 1,
      }));
    },

    _addHeaders: (
      namespace: AutogeneratedFieldsNamespace,
      params: Record<string, { value: string; prettyValue?: string }>
    ) => {
      const { headerVersion, namespaces } = get();
      const updatedHeaders = new Map<string, { value: string; prettyValue?: string }>();

      Object.entries(params).forEach(([key, value]) => {
        updatedHeaders.set(key, {
          value: value.value,
          prettyValue: value.prettyValue,
        });
      });

      const updatedState = {
        namespaces: {
          ...namespaces,
          [namespace]: {
            ...namespaces[namespace],
            headers: updatedHeaders,
          },
        },
        headerVersion: headerVersion + 1,
      };
      set(updatedState);
    },

    clearNamespace: (namespace: AutogeneratedFieldsNamespace, skipVersionUpdate = false) => {
      // logic to clear all the namespace
      let { headerVersion, queryParamsVersion, namespaces } = get();
      namespaces[namespace] = {
        headers: new Map(),
        queryParams: [],
      };
      if (!skipVersionUpdate) {
        headerVersion++;
        queryParamsVersion++;
      }
      set({
        namespaces,
        headerVersion,
        queryParamsVersion,
      });
    },
    purgeAndAddHeaders: (
      namespace: AutogeneratedFieldsNamespace,
      params: Record<string, { value: string; prettyValue?: string }>
    ) => {
      const { clearNamespace, _addHeaders } = get();
      clearNamespace(namespace, true);
      _addHeaders(namespace, params);
    },

    _addQueryparams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => {
      const { queryParamsVersion, namespaces } = get();

      const updatedState = {
        namespaces: {
          ...namespaces,
          [namespace]: {
            ...namespaces[namespace],
            queryParams: params,
          },
        },
        queryParamsVersion: queryParamsVersion + 1,
      };
      set(updatedState);
    },

    purgeAndAddQueryParams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => {
      const { clearNamespace, _addQueryparams } = get();
      clearNamespace(namespace, true);
      _addQueryparams(namespace, params);
    },

    purgeAndAdd: (
      namespace: AutogeneratedFieldsNamespace,
      headers: Record<string, { value: string; prettyValue?: string }>,
      queryParams: SimpleKeyValuePair[]
    ) => {
      const { clearNamespace, _addQueryparams, _addHeaders } = get();

      clearNamespace(namespace, true);
      _addHeaders(namespace, headers);
      _addQueryparams(namespace, queryParams);
    },

    getHeadersToShow() {
      //this will be used only for autogenerated headers
      // if pretty value is available show the value else fallback to original value of argument
      const { namespaces } = get();
      return collectHeaders(namespaces, (value) => value.prettyValue ?? value.value);
    },

    getHeadersOnPrepareRequest() {
      const { namespaces } = get();
      return collectHeaders(namespaces, (value) => value.value);
    },

    getAllQueryParams() {
      const result: SimpleKeyValuePair[] = [];
      const { namespaces } = get();
      for (const namespace in namespaces) {
        const { queryParams } = namespaces[namespace as AutogeneratedFieldsNamespace];
        for (const queryParam of queryParams) {
          result.push({
            key: queryParam.key,
            value: queryParam.value,
          });
        }
      }
      return result;
    },
  }));
};
