import { create } from "zustand";
import { RequestContentType, RQAPI } from "../types";
import { extractAuthHeadersAndParams } from "../helpers/auth";
import { Headers } from "../constants";
export type SimpleKeyValuePair = { key: string; value: string };

export enum AutogeneratedFieldsNamespace {
  AUTH = "auth",
  CONTENT_TYPE = "content_type",
}
export enum PrettifiedHeaders {
  MULTI_PART_FORM = "multipart/form-data; boundary=<calculated when request is sent>",
}
interface HeaderEntry {
  value: string;
  placeHolder?: string;
}

/*
Resolve the headers having prettyValue
*/
const createHeaderEntryFrom = (value: string): HeaderEntry => {
  switch (value) {
    case RequestContentType.MULTIPART_FORM:
      return { value: value, placeHolder: PrettifiedHeaders.MULTI_PART_FORM };

    default:
      return {
        value: value,
      };
  }
};

/*
create resolver functions for headers to add
*/
export const createHeaderEntry = (key: string, value: string): HeaderEntry => {
  switch (key) {
    case Headers.CONTENT_TYPE: {
      return createHeaderEntryFrom(value);
    }
    default: {
      return { value };
    }
  }
};

interface NamespaceContents {
  queryParams: SimpleKeyValuePair[];
  headers: Map<string, HeaderEntry>;
}

export interface AutogeneratedFieldsStore {
  namespaces: Partial<Record<AutogeneratedFieldsNamespace, NamespaceContents>>;
  headerVersion: number;
  queryParamsVersion: number;

  //Header methods
  initialize: (namespaces: AutogeneratedFieldsStore["namespaces"]) => void;
  _addHeaders: (namespace: AutogeneratedFieldsNamespace, params: Record<string, HeaderEntry>) => void;
  clearNamespace: (namespace: AutogeneratedFieldsNamespace, skipVersionUpdate?: boolean) => void;
  purgeAndAddHeaders: (namespace: AutogeneratedFieldsNamespace, params: Record<string, HeaderEntry>) => void;
  getPlaceholderHeaders: () => SimpleKeyValuePair[];
  getAllHeaders: () => SimpleKeyValuePair[];
  getAllQueryParams: () => SimpleKeyValuePair[];
  _addQueryparams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => void;
  purgeAndAddQueryParams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => void;
  purgeAndAdd: (
    namespace: AutogeneratedFieldsNamespace,
    headers: Record<string, HeaderEntry>,
    queryParams: SimpleKeyValuePair[]
  ) => void;
}
export function parseAuth(
  auth: RQAPI.Auth,
  resolver?: <U extends Record<string, any>>(input: U) => U
): NamespaceContents {
  // extract the auth from config & push them in header map
  // handle how i will store the key value pair here
  // ---> now here we can use that function already defined since it has the same signature of params
  const { headers, queryParams } = extractAuthHeadersAndParams(resolver ? resolver(auth) : auth);
  //convert the headers from KP to map
  const headersMap = new Map<string, HeaderEntry>();
  headers.forEach(({ key, value }) => {
    headersMap.set(key, { value: value });
  });

  const queryParamsContent: SimpleKeyValuePair[] = [];
  queryParams.forEach(({ key, value }) => {
    queryParamsContent.push({ key, value });
  });

  return {
    queryParams: queryParamsContent,
    headers: headersMap,
  };
}

export function parseContentType(contentType: RequestContentType): NamespaceContents {
  const queryParams: SimpleKeyValuePair[] = [];
  const headersMap = new Map<string, HeaderEntry>();

  headersMap.set(Headers.CONTENT_TYPE, createHeaderEntry(Headers.CONTENT_TYPE, contentType));
  return {
    queryParams,
    headers: headersMap,
  };
}

export const createAutogeneratedStore = () => {
  return create<AutogeneratedFieldsStore>()((set, get) => ({
    namespaces: {},
    headerVersion: 0,
    queryParamsVersion: 0,

    initialize: (namespaces: AutogeneratedFieldsStore["namespaces"]) => {
      set((state) => ({
        namespaces,
        headerVersion: state.headerVersion + 1,
      }));
    },

    _addHeaders: (namespace: AutogeneratedFieldsNamespace, params: Record<string, HeaderEntry>) => {
      const { headerVersion, namespaces } = get();
      const updatedHeaders = new Map<string, HeaderEntry>();

      Object.entries(params).forEach(([key, value]) => {
        updatedHeaders.set(key, {
          value: value.value,
          placeHolder: value.placeHolder,
        });
      });

      const updatedState = {
        namespaces: {
          ...namespaces,
          [namespace]: {
            ...namespaces[namespace],
            headers: updatedHeaders,
          },
        },
        headerVersion: headerVersion + 1,
      };
      set(updatedState);
    },

    clearNamespace: (namespace: AutogeneratedFieldsNamespace, skipVersionUpdate = false) => {
      // logic to clear all the namespace
      let { headerVersion, queryParamsVersion, namespaces } = get();
      namespaces[namespace] = {
        headers: new Map(),
        queryParams: [],
      };
      if (!skipVersionUpdate) {
        headerVersion++;
        queryParamsVersion++;
      }
      set({
        namespaces,
        headerVersion,
        queryParamsVersion,
      });
    },
    purgeAndAddHeaders: (namespace: AutogeneratedFieldsNamespace, params: Record<string, HeaderEntry>) => {
      const { clearNamespace, _addHeaders } = get();
      clearNamespace(namespace, true);
      _addHeaders(namespace, params);
    },

    _addQueryparams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => {
      const { queryParamsVersion, namespaces } = get();

      const updatedState = {
        namespaces: {
          ...namespaces,
          [namespace]: {
            ...namespaces[namespace],
            queryParams: params,
          },
        },
        queryParamsVersion: queryParamsVersion + 1,
      };
      set(updatedState);
    },

    purgeAndAddQueryParams: (namespace: AutogeneratedFieldsNamespace, params: SimpleKeyValuePair[]) => {
      const { clearNamespace, _addQueryparams } = get();
      clearNamespace(namespace, true);
      _addQueryparams(namespace, params);
    },

    purgeAndAdd: (
      namespace: AutogeneratedFieldsNamespace,
      headers: Record<string, HeaderEntry>,
      queryParams: SimpleKeyValuePair[]
    ) => {
      const { clearNamespace, _addQueryparams, _addHeaders } = get();

      clearNamespace(namespace, true);
      _addHeaders(namespace, headers);
      _addQueryparams(namespace, queryParams);
    },

    getPlaceholderHeaders() {
      const result: SimpleKeyValuePair[] = [];
      const { namespaces } = get();
      for (const namespace in namespaces) {
        const namespaceContent = namespaces[namespace as AutogeneratedFieldsNamespace];
        if (!namespaceContent) continue;
        const { headers } = namespaceContent;
        for (const headerEntry of headers.entries()) {
          const [key, value] = headerEntry;
          const headerValue = value.placeHolder ?? value.value;
          result.push({
            key,
            value: headerValue,
          });
        }
      }
      return result;
    },

    getAllHeaders() {
      const result: SimpleKeyValuePair[] = [];
      const { namespaces } = get();
      for (const namespace in namespaces) {
        const namespaceContent = namespaces[namespace as AutogeneratedFieldsNamespace];
        if (!namespaceContent) continue;
        const { headers } = namespaceContent;
        for (const headerEntry of headers.entries()) {
          const [key, { value }] = headerEntry;
          result.push({
            key,
            value,
          });
        }
      }
      return result;
    },

    getAllQueryParams() {
      const result: SimpleKeyValuePair[] = [];
      const { namespaces } = get();
      for (const namespace in namespaces) {
        const namespaceContent = namespaces[namespace as AutogeneratedFieldsNamespace];
        if (!namespaceContent) continue;
        const { queryParams } = namespaceContent;
        for (const queryParam of queryParams) {
          result.push({
            key: queryParam.key,
            value: queryParam.value,
          });
        }
      }
      return result;
    },
  }));
};
