import { getAppMode } from "store/selectors";
import { useApiClientFeatureContext, useApiClientRepository } from "../contexts/meta";
import { useSelector } from "react-redux";
import { useApiClientContext } from "../contexts";
import { AutogenerateStoreContext } from "../store/autogenerateContextProvider";
import { useCallback, useContext, useMemo, useRef } from "react";
import { RequestPreparationService } from "../helpers/requestPreparationService";
import { RequestValidationService } from "../helpers/requestValidationService";
import { ScriptExecutionService } from "../helpers/scriptExecutionService";
import { RequestExecutorService } from "../helpers/requestExecutorService";
import { renderVariables } from "backend/environment/utils";
import { useAPIEnvironment } from "../store/apiRecords/ApiRecordsContextProvider";
import { useCommand } from "../commands";
import { patchRuntimeStore } from "../store/runtimeVariables/utils";

export const useHttpRequestExecutor = (collectionId: string) => {
  const ctx = useApiClientFeatureContext();
  const appMode = useSelector(getAppMode);
  const { apiClientWorkloadManager } = useApiClientContext();
  const autoGeneratedStore = useContext(AutogenerateStoreContext);
  const [getActiveEnvironment] = useAPIEnvironment((s) => [s.getActiveEnvironment]);
  const {
    env: { patchEnvironmentVariables },
    api: { patchCollectionVariables },
  } = useCommand();
  const { environmentVariablesRepository } = useApiClientRepository();

  const abortControllerRef = useRef(new AbortController());

  const handleUpdatesFromExecutionWorker = useCallback(
    async (state: any) => {
      for (const key in state) {
        if (key === "environment") {
          const activeEnvironment = getActiveEnvironment();
          if (activeEnvironment) {
            await patchEnvironmentVariables({ environmentId: activeEnvironment.id, variables: state[key] });
          }
        }
        if (key === "global") {
          const globalEnvId = environmentVariablesRepository.getGlobalEnvironmentId();
          await patchEnvironmentVariables({ environmentId: globalEnvId, variables: state[key] });
        }
        if (key === "collectionVariables") {
          if (!collectionId) {
            return;
          }

          await patchCollectionVariables({
            collectionId,
            variables: state[key],
          });
        }
        if (key === "variables") {
          patchRuntimeStore(state[key]);
        }
      }
    },
    [
      collectionId,
      environmentVariablesRepository,
      getActiveEnvironment,
      patchCollectionVariables,
      patchEnvironmentVariables,
    ]
  );

  return useMemo(() => {
    const requestPreparer = new RequestPreparationService(ctx, autoGeneratedStore, renderVariables);
    const requestValidator = new RequestValidationService();
    const scriptExecutor = new ScriptExecutionService(ctx, apiClientWorkloadManager, abortControllerRef.current);

    return new RequestExecutorService(
      requestPreparer,
      requestValidator,
      scriptExecutor,
      abortControllerRef.current,
      handleUpdatesFromExecutionWorker,
      appMode
    );
  }, [apiClientWorkloadManager, appMode, autoGeneratedStore, ctx, handleUpdatesFromExecutionWorker]);
};
