import lodash from "lodash";
import { RequestContentType, RQAPI } from "features/apiClient/types";
import GraphQLClientUrl from "./components/GraphQLClientUrl/GraphQLClientUrl";
import React, { useCallback, useEffect, useState } from "react";
import { toast } from "utils/Toast";
import { useDispatch, useSelector } from "react-redux";
import { useGraphQLIntrospection } from "features/apiClient/hooks/useGraphQLIntrospection";
import { useGraphQLRecordStore } from "features/apiClient/hooks/useGraphQLRecordStore";
import { useDebounce } from "hooks/useDebounce";
import { RevertViewModeChangesAlert, RoleBasedComponent } from "features/rbac";
import { Conditional } from "components/common/Conditional";
import { getUserAuthDetails } from "store/slices/global/user/selectors";
import { notification, Space } from "antd";
import { ApiClientBreadCrumb, BreadcrumbType } from "../components/ApiClientBreadCrumb/ApiClientBreadCrumb";
import { BottomSheetLayout, useBottomSheetContext } from "componentsV2/BottomSheet";
import { BottomSheetPlacement, SheetLayout } from "componentsV2/BottomSheet/types";
import { GraphQLRequestTabs } from "./components/GraphQLRequestTabs/GraphQLRequestTabs";
import { ApiClientBottomSheet } from "../components/response/ApiClientBottomSheet/ApiClientBottomSheet";
import { ClientCodeButton } from "../components/ClientCodeButton/ClientCodeButton";
import "./gqClientView.scss";
import { isNull } from "lodash";
import { useAutogenerateStore } from "features/apiClient/hooks/useAutogenerateStore";
import { AutogeneratedFieldsNamespace, createHeaderEntry } from "features/apiClient/store/autogenerateStore";
import { SendQueryButton } from "./components/SendQueryButton/SendQueryButton";
import { DEFAULT_REQUEST_NAME, INVALID_KEY_CHARACTERS } from "features/apiClient/constants";
import { Authorization } from "../components/request/components/AuthorizationView/types/AuthConfig";
import {
  trackAPIRequestSent,
  trackInstallExtensionDialogShown,
  trackRequestRenamed,
  trackRequestSaved,
  trackTestGenerationCompleted,
  trackTestGenerationFailed,
  trackTestGenerationStarted,
} from "modules/analytics/events/features/apiClient";
import { extractOperationNames } from "./utils";
import ErrorBoundary from "features/apiClient/components/ErrorBoundary/ErrorBoundary";
import { getContentTypeFromResponseHeaders, getEmptyDraftApiRecord, getRequestTypeForAnalyticEvent } from "../../../utils";
import { useGraphQLRequestExecutor } from "features/apiClient/hooks/requestExecutors/useGraphQLRequestExecutor";
import { isExtensionInstalled } from "actions/ExtensionActions";
import { isDesktopMode } from "utils/AppUtils";
import { globalActions } from "store/slices/global/slice";
import {
  buildAutogeneratedTestsBlock,
  hasTests,
  injectAutogeneratedTests,
} from "features/apiClient/helpers/testGeneration/buildPostResponseTests";
import { useDeepLinkState } from "hooks";
import { RequestTab } from "../http/components/HttpRequestTabs/HttpRequestTabs";
import { useAISessionContext } from "features/ai/contexts/AISession";
import { BufferedGraphQLRecordEntity, useIsBufferDirty } from "features/apiClient/slices/entities";
import { useApiClientSelector } from "features/apiClient/slices/hooks/base.hooks";
import {
  ApiClientStore,
  bufferActions,
  bufferAdapterSelectors,
  useApiClientRepository,
  useApiClientStore,
} from "features/apiClient/slices";
import { useSaveBuffer } from "features/apiClient/slices/buffer/hooks";
import { NativeError } from "errors/NativeError";
import { useHostContext } from "hooks/useHostContext";
import { sanitizeKeyValuePairs } from "../../../utils";
import { GraphQLRecordProvider } from "features/apiClient/store/apiRecord/graphqlRecord/GraphQLRecordContextProvider";
import { GenericApiClientOverride } from "../../../clientView/GenericApiClient";
import { SaveRequestButton } from "../components/SaveRequestButton/SaveRequestButton";
import { MdArrowOutward } from "@react-icons/all-files/md/MdArrowOutward";
import { DraftRequestContainerTabSource } from "../components/DraftRequestContainer/draftRequestContainerTabSource";
import { useTabActions } from "componentsV2/Tabs/slice";
import { RQButton } from "lib/design-system-v2/components";

function getEntry(entity: BufferedGraphQLRecordEntity, store: ApiClientStore) {
  return entity.getEntityFromState(store.getState()).data;
}

export type GraphQLClientViewProps = {
  entity: BufferedGraphQLRecordEntity;
  override?: GenericApiClientOverride;
  openInModal?: boolean;
  notifyApiRequestFinished: (apiEntry: RQAPI.GraphQLApiEntry) => void;
};

const GraphQLClientView: React.FC<GraphQLClientViewProps> = ({
  openInModal = false,
  notifyApiRequestFinished,
  entity,
  override,
}) => {
  const dispatch = useDispatch();
  const user = useSelector(getUserAuthDetails);
  const { sheetPlacement } = useBottomSheetContext();

  const store = useApiClientStore();
  const repositories = useApiClientRepository();

  const { getIsActive } = useHostContext();
  const { openBufferedTab } = useTabActions();

  const hasUnsavedChanges = useIsBufferDirty({
    type: "bufferId",
    bufferId: entity.id,
  });

  const url = useApiClientSelector((s) => entity.getUrl(s));
  const name = useApiClientSelector((s) => entity.getName(s) || "Untitled request");
  const isNew = useApiClientSelector((s) => bufferAdapterSelectors.selectById(s.buffer, entity.id)?.isNew) ?? false;
  const isExample = useApiClientSelector((s) => entity.getType(s) === RQAPI.RecordType.EXAMPLE_API);

  const introspectionData = useGraphQLRecordStore((state) => state.introspectionData);

  const enableHotkey = getIsActive();

  const [, setDeepLinkState] = useDeepLinkState({ tab: RequestTab.QUERY_PARAMS });

  const [isGeneratingTests, setIsGeneratingTests] = useState(false);
  const [scriptEditorVersion, setScriptEditorVersion] = useState(0);

  const [focusPostResponseScriptEditor, setFocusPostResponseScriptEditor] = useState(false);

  const [isRequestSaving, setIsRequestSaving] = useState(false);
  const [isSending, setIsSending] = useState(false);

  const [error, setError] = useState<RQAPI.ExecutionError | null>(null);
  const [warning, setWarning] = useState<RQAPI.ExecutionWarning | null>(null);
  const [isRequestCancelled, setIsRequestCancelled] = useState(false);
  const [isRequestFailed, setIsRequestFailed] = useState(false);
  const [isSchemaBuilderOpen, setIsSchemaBuilderOpen] = useState(true);

  const graphQLRequestExecutor = useGraphQLRequestExecutor(entity.meta.referenceId);

  const { endAISession } = useAISessionContext();

  const saveBuffer = useSaveBuffer();

  const handleGenerateTests = useCallback(async () => {
    const entry = getEntry(entity, store);
    if (!entry?.response || isGeneratingTests) {
      return;
    }

    setIsGeneratingTests(true);
    trackTestGenerationStarted({
      src: "test_tab_response_panel",
    });
    const method = "POST";
    const status = entry.response.status;

    let hasJsonObjectBody = false;
    try {
      const contentType = getContentTypeFromResponseHeaders(entry.response.headers) ?? "";
      const isJson = /application\/json/i.test(contentType);
      if (isJson) {
        const parsed = JSON.parse(entry.response.body || "null");
        hasJsonObjectBody = parsed && typeof parsed === "object" && !Array.isArray(parsed);
      }
    } catch (_) {
      hasJsonObjectBody = false;
    }

    try {
      const existingScript = entry.scripts?.postResponse || "";
      if (hasTests(existingScript)) {
        setIsGeneratingTests(false);
        return;
      }
      const block = buildAutogeneratedTestsBlock({
        method,
        status,
        hasJsonObjectBody,
      });

      setFocusPostResponseScriptEditor(true);
      const newScript = injectAutogeneratedTests(existingScript, block);
      entity.setPostResponseScript(newScript);

      setScriptEditorVersion((prev) => prev + 1);
      setDeepLinkState({ tab: RequestTab.SCRIPTS });
      trackTestGenerationCompleted({
        src: "test_tab_response_panel",
      });
    } catch (e) {
      toast.error("Something went wrong while generating tests");
      trackTestGenerationFailed({
        src: "test_tab_response_panel",
      });
    } finally {
      setIsGeneratingTests(false);
    }
  }, [isGeneratingTests, setDeepLinkState, entity, store]);

  const handleUrlChange = useCallback(
    (value: string) => {
      entity.setUrl(value);
    },
    [entity]
  );

  const { introspectAndSaveSchema } = useGraphQLIntrospection({
    recordId: entity.meta.referenceId,
    url,
  });
  const [purgeAndAddHeaders] = useAutogenerateStore((state) => [state.purgeAndAddHeaders]);

  const debouncedIntrospection = useDebounce(introspectAndSaveSchema, 500);

  useEffect(() => {
    if (url && isNull(introspectionData)) {
      debouncedIntrospection();
    }
  }, [url, debouncedIntrospection, introspectionData]);

  const handleUrlInputEnterPressed = useCallback((evt: KeyboardEvent) => {
    (evt.target as HTMLInputElement).blur();
  }, []);

  useEffect(() => {
    purgeAndAddHeaders(AutogeneratedFieldsNamespace.CONTENT_TYPE, {
      "Content-Type": createHeaderEntry("Content-Type", RequestContentType.JSON),
    });
  }, [purgeAndAddHeaders]);

  const onSaveButtonClick = useCallback(async () => {
    saveBuffer(
      {
        entity,
        skipMarkSaved: override?.onSaveClick?.skipMarkSaved,
        produceChanges(entity, state) {
          const record = lodash.cloneDeep(entity.getEntityFromState(state));
          const entry = record.data;

          // Sanitize headers
          if (entry.request?.headers) {
            entry.request.headers = sanitizeKeyValuePairs(entry.request.headers, true);
          }

          const isValidHeader = entry.request?.headers?.every((header) => {
            return !header.isEnabled || !INVALID_KEY_CHARACTERS.test(header.key);
          });

          const isValidAuthKey =
            entry.auth?.currentAuthType !== Authorization.Type.API_KEY ||
            !entry.auth?.authConfigStore?.API_KEY?.key ||
            !INVALID_KEY_CHARACTERS.test(entry.auth?.authConfigStore?.API_KEY?.key) ||
            entry.auth?.authConfigStore?.API_KEY.addTo === "QUERY";

          if (!isValidHeader || !isValidAuthKey) {
            throw new NativeError("Request contains invalid characters!");
          }

          const operationNames = extractOperationNames(entry.request.operation);
          const hasDefaultOrEmptyName = !record.name || record.name === DEFAULT_REQUEST_NAME;
          const hasSingleOperation = operationNames.length === 1;

          if (hasDefaultOrEmptyName && hasSingleOperation && operationNames[0]) {
            record.name = operationNames[0];
          } else if (!record.name) {
            record.name = DEFAULT_REQUEST_NAME;
          }

          const { operationName, ...requestWithoutOperationName } = entry.request;
          entry.request = requestWithoutOperationName;

          return record;
        },
        async save(record, repositories) {
          if (override?.onSaveClick) {
            return override.onSaveClick.save(record, repositories) as Promise<RQAPI.GraphQLApiRecord>;
          }
          const result = await repositories.apiClientRecordsRepository.updateRecord(record, record.id);
          if (!result.success) {
            throw new NativeError(result.message || "Could not save request!");
          }
          return result.data as RQAPI.GraphQLApiRecord;
        },
      },
      {
        beforeSave() {
          setIsRequestSaving(true);
        },
        afterSave() {
          setIsRequestSaving(false);
        },
        onSuccess(result) {
          toast.success("Request saved!");
          trackRequestSaved({
            src: "api_client_view",
            has_scripts: Boolean(result.data?.scripts?.preRequest),
            auth_type: result.data?.auth?.currentAuthType,
            type: RQAPI.ApiEntryType.GRAPHQL,
          });
          override?.onSaveClick?.onSuccess(result);
        },
        onError(e) {
          notification.error({
            message: `Could not save request.`,
            description: e.message,
            placement: "bottomRight",
          });
        },
      }
    );

    endAISession();
  }, [override, endAISession, saveBuffer, entity]);

  const handleRecordNameUpdate = useCallback(
    async (newName: string) => {
      const record = lodash.cloneDeep(entity.getEntityFromState(store.getState()));
      record.name = newName;
      const result = await repositories.apiClientRecordsRepository.updateRecord(record, entity.meta.referenceId);
      if (!result.success) {
        notification.error({
          message: "Could not rename request",
          description: result?.message,
          placement: "bottomRight",
        });
        return;
      }
      entity.origin.setName(newName);
      trackRequestRenamed("breadcrumb");
    },
    [entity, repositories, store]
  );

  const handleRevertChanges = useCallback(() => {
    if (!entity.meta.originExists) {
      return; // Can't revert if there's no origin
    }
    const originState = entity.origin.getEntityFromState(store.getState());
    store.dispatch(
      bufferActions.revertChanges({
        referenceId: entity.meta.referenceId!,
        sourceData: originState,
      })
    );
  }, [entity, store]);

  const resetState = useCallback(() => {
    setError(null);
    setWarning(null);
    setIsRequestCancelled(false);
    setIsRequestFailed(false);
    entity.setResponse(null);
  }, [entity]);

  const handleSend = useCallback(
    async (operationName?: string) => {
      if (!isExtensionInstalled() && !isDesktopMode()) {
        /* SHOW INSTALL EXTENSION MODAL */
        const modalProps = {
          heading: "Install browser Extension to use the API Client",
          subHeading:
            "A minimalistic API Client for front-end developers to test their APIs and fast-track their web development lifecycle. Add custom Headers and Query Params to test your APIs.",
          eventPage: "api_client",
        };
        dispatch(globalActions.toggleActiveModal({ modalName: "extensionModal", newProps: modalProps }));
        trackInstallExtensionDialogShown({ src: "api_client" });
        return;
      }

      const entry = getEntry(entity, store);
      try {
        resetState();
        setIsSending(true);

        const entryWithOperationName = operationName
          ? { ...entry, request: { ...entry.request, operationName } }
          : entry;

        const apiClientExecutionResult = await graphQLRequestExecutor.executeGraphQLRequest(
          {
            entry: entryWithOperationName,
            recordId: entity.meta.referenceId,
          },
          {
            iteration: 0,
            iterationCount: 1,
          }
        );

        const executedEntry = apiClientExecutionResult.executedEntry as RQAPI.GraphQLApiEntry;
        entity.setResponse(executedEntry.response);
        entity.setTestResults(executedEntry.testResults);

        notifyApiRequestFinished(executedEntry);
        trackAPIRequestSent({
          has_scripts: Boolean(entry.scripts?.preRequest),
          auth_type: entry.auth?.currentAuthType,
          request_type: getRequestTypeForAnalyticEvent(false, entry.request?.url),
          type: RQAPI.ApiEntryType.GRAPHQL,
        });

        if (apiClientExecutionResult.status === RQAPI.ExecutionStatus.SUCCESS) {
          if (apiClientExecutionResult.warning) {
            setWarning(apiClientExecutionResult.warning);
          }
        } else if (apiClientExecutionResult.status === RQAPI.ExecutionStatus.ERROR) {
          setError(apiClientExecutionResult.error ?? null);
          setIsRequestFailed(true);
        }
      } catch (error) {
        setIsRequestFailed(true);
        setError(error as RQAPI.ExecutionError);
      } finally {
        setIsSending(false);
        endAISession();
      }
    },
    [entity, store, resetState, graphQLRequestExecutor, notifyApiRequestFinished, dispatch, endAISession]
  );

  const handleTestResultRefresh = useCallback(async () => {
    try {
      const entry = getEntry(entity, store);
      const { preparedEntry } = graphQLRequestExecutor.prepareGraphQLRequest(entity.meta.referenceId, entry);

      const result = await graphQLRequestExecutor.rerun(entity.meta.referenceId, preparedEntry);
      if (result.status === RQAPI.ExecutionStatus.SUCCESS) {
        entity.setTestResults(result.artifacts.testResults);
      } else {
        setError(result.error ?? null);
      }
    } catch {
      toast.error("Something went wrong while refreshing test results");
    }
  }, [graphQLRequestExecutor, entity, store]);

  const handleCancelRequest = useCallback(() => {
    graphQLRequestExecutor.abort();
    setIsRequestCancelled(true);
  }, [graphQLRequestExecutor]);

  const handleUseAsTemplate = useCallback(() => {
    openBufferedTab({
      isNew: true,
      preview: false,
      source: new DraftRequestContainerTabSource({
        apiEntryType: RQAPI.ApiEntryType.GRAPHQL,
        context: {},
        emptyRecord: getEmptyDraftApiRecord(
          RQAPI.ApiEntryType.GRAPHQL,
          entity.getEntityFromState(store.getState()).data
        ),
      }),
    });
  }, [entity, store, openBufferedTab]);

  return (
    <div className="api-client-view gql-client-view">
      <div className="api-client-header-container">
        <RoleBasedComponent
          permission="create"
          resource="api_client_request"
          fallback={
            <Conditional condition={user.loggedIn && !openInModal && hasUnsavedChanges}>
              <RevertViewModeChangesAlert
                title="As a viewer, You can modify and test APIs, but cannot save updates."
                callback={handleRevertChanges}
              />
            </Conditional>
          }
        />
        <div className="api-client-header-container__header">
          <div className="api-client-breadcrumb-container">
            <ApiClientBreadCrumb
              id={entity.meta.referenceId}
              placeholder="Untitled request"
              openInModal={openInModal}
              name={name}
              autoFocus={isNew}
              isDraft={!!isNew}
              onBlur={(newName) => {
                if (override?.handleNameChange) {
                  override.handleNameChange(newName);
                  return;
                }
                handleRecordNameUpdate(newName);
              }}
              breadCrumbType={BreadcrumbType.API_REQUEST}
            />

            <ClientCodeButton
              requestPreparer={() => {
                const entry = getEntry(entity, store);
                return graphQLRequestExecutor.prepareGraphQLRequest(entity.meta.referenceId, entry).preparedEntry
                  .request;
              }}
            />
          </div>

          <div className="api-client-header__url">
            <Space.Compact className="api-client-url-container">
              <GraphQLClientUrl
                entity={entity}
                onEnterPress={handleUrlInputEnterPressed}
                onUrlChange={handleUrlChange}
              />
            </Space.Compact>
            {isExample ? (
              <RQButton type="primary" className="api-client-use-as-template-button" onClick={handleUseAsTemplate}>
                Use as template <MdArrowOutward />
              </RQButton>
            ) : (
              <SendQueryButton entity={entity} disabled={!url} loading={isSending} onSendClick={handleSend} />
            )}

            <SaveRequestButton
              disabled={!hasUnsavedChanges}
              loading={isRequestSaving}
              hidden={openInModal}
              enableHotkey={enableHotkey}
              onClick={onSaveButtonClick}
              entity={entity}
            />
          </div>
        </div>
      </div>
      <BottomSheetLayout
        layout={SheetLayout.SPLIT}
        bottomSheet={
          <ApiClientBottomSheet
            entity={entity}
            onGenerateTests={handleGenerateTests}
            isGeneratingTests={isGeneratingTests}
            isLoading={isSending}
            isFailed={isRequestFailed}
            isLongRequest={false}
            isRequestCancelled={isRequestCancelled}
            onCancelRequest={handleCancelRequest}
            handleTestResultRefresh={handleTestResultRefresh}
            error={error}
            onDismissError={resetState}
            warning={warning}
            executeRequest={handleSend}
          />
        }
        initialSizes={sheetPlacement === BottomSheetPlacement.BOTTOM ? [60, 40] : [60, 40]}
      >
        <div className="api-client-body">
          <GraphQLRequestTabs
            entity={entity}
            isSchemaBuilderOpen={isSchemaBuilderOpen}
            setIsSchemaBuilderOpen={setIsSchemaBuilderOpen}
            focusPostResponseScriptEditor={focusPostResponseScriptEditor}
            scriptEditorVersion={scriptEditorVersion}
          />
        </div>
      </BottomSheetLayout>
    </div>
  );
};

const WithGraphQLRecordProvider = (Component: React.ComponentType<any>): React.FC<GraphQLClientViewProps> => {
  return (props) => {
    return (
      <ErrorBoundary boundaryId="graphql-client-view-error-boundary">
        <GraphQLRecordProvider>
          <Component {...props} />
        </GraphQLRecordProvider>
      </ErrorBoundary>
    );
  };
};

export default React.memo(WithGraphQLRecordProvider(GraphQLClientView));
