import { useGraphQLRecordStore } from "features/apiClient/hooks/useGraphQLRecordStore";
import { RequestContentType, RQAPI } from "features/apiClient/types";
import GraphQLClientUrl from "./components/GraphQLClientUrl/GraphQLClientUrl";
import React, { useCallback, useContext, useEffect, useLayoutEffect, useRef, useState } from "react";
import { RQButton } from "lib/design-system-v2/components";
import { useApiClientContext } from "features/apiClient/contexts";
import { toast } from "utils/Toast";
import { useSelector } from "react-redux";
import { getAppMode } from "store/selectors";
import { AutogenerateStoreContext } from "features/apiClient/store/autogenerateContextProvider";
import { GraphQLRequestExecutor } from "features/apiClient/helpers/graphQLRequestExecutor/GraphQLRequestExecutor";
import { useGraphQLIntrospection } from "features/apiClient/hooks/useGraphQLIntrospection";
import { useDebounce } from "hooks/useDebounce";
import { RBACButton, RevertViewModeChangesAlert, RoleBasedComponent } from "features/rbac";
import { Conditional } from "components/common/Conditional";
import { getUserAuthDetails } from "store/slices/global/user/selectors";
import { Space } from "antd";
import { ApiClientBreadCrumb } from "../components/ApiClientBreadCrumb/ApiClientBreadCrumb";
import { KEYBOARD_SHORTCUTS } from "../../../../../../../constants/keyboardShortcuts";
import { useGenericState } from "hooks/useGenericState";
import { BottomSheetLayout, useBottomSheetContext } from "componentsV2/BottomSheet";
import { BottomSheetPlacement, SheetLayout } from "componentsV2/BottomSheet/types";
import { GraphQLRequestTabs } from "./components/GraphQLRequestTabs/GraphQLRequestTabs";
import { ApiClientBottomSheet } from "../components/response/ApiClientBottomSheet/ApiClientBottomSheet";
import { ClientCodeButton } from "../components/ClientCodeButton/ClientCodeButton";
import "./gqClientView.scss";
import { GraphQLRecordProvider } from "features/apiClient/store/apiRecord/graphqlRecord/GraphQLRecordContextProvider";
import { GrGraphQl } from "@react-icons/all-files/gr/GrGraphQl";
import { isNull } from "lodash";
import { useLocation } from "react-router-dom";
import PATHS from "config/constants/sub/paths";
import { useAutogenerateStore } from "features/apiClient/hooks/useAutogenerateStore";
import { AutogeneratedFieldsNamespace, createHeaderEntry } from "features/apiClient/store/autogenerateStore";
import { ApiClientFilesContext } from "features/apiClient/store/ApiClientFilesContextProvider";
import { useApiClientRepository } from "features/apiClient/helpers/modules/sync/useApiClientSyncRepo";
import { useApiClientFeatureContext } from "features/apiClient/contexts/meta";
import { useScopedVariables } from "features/apiClient/helpers/variableResolver/variable-resolver";
import { useAPIEnvironment } from "features/apiClient/store/apiRecords/ApiRecordsContextProvider";
import { useCommand } from "features/apiClient/commands";

interface Props {
  notifyApiRequestFinished: (entry: RQAPI.GraphQLApiEntry) => void;
  onSaveCallback: (apiEntryDetails: RQAPI.GraphQLApiRecord) => void;
  isCreateMode: boolean;
  openInModal?: boolean;
}

const GraphQLClientView: React.FC<Props> = ({
  notifyApiRequestFinished,
  onSaveCallback,
  isCreateMode,
  openInModal = false,
}) => {
  const [
    recordId,
    url,
    collectionId,
    response,
    testResults,
    hasUnsavedChanges,
    introspectionData,
    isFetchingIntrospectionData,
    hasIntrospectionFailed,
    updateRecordRequest,
    updateRecord,
    getRecord,
    getRecordName,
    updateRecordResponse,
    setHasUnsavedChanges,
    updateRecordTestResults,
  ] = useGraphQLRecordStore((state) => [
    state.record.id,
    state.record.data.request.url,
    state.record.collectionId,
    state.record.data.response,
    state.record.data.testResults,
    state.hasUnsavedChanges,
    state.introspectionData,
    state.isFetchingIntrospectionData,
    state.hasIntrospectionFailed,
    state.updateRecordRequest,
    state.updateRecord,
    state.getRecord,
    state.getRecordName,
    state.updateRecordResponse,
    state.setHasUnsavedChanges,
    state.updateRecordTestResults,
  ]);

  const { apiClientRecordsRepository, environmentVariablesRepository } = useApiClientRepository();
  const { onSaveRecord, apiClientWorkloadManager } = useApiClientContext();
  const { sheetPlacement, toggleSheetPlacement } = useBottomSheetContext();

  const location = useLocation();

  const user = useSelector(getUserAuthDetails);
  const appMode = useSelector(getAppMode);

  const { getIsActive, setUnsaved, setIcon, setTitle } = useGenericState();

  const ctx = useApiClientFeatureContext();
  const [getActiveEnvironment] = useAPIEnvironment((s) => [s.getActiveEnvironment]);
  const {
    env: { patchEnvironmentVariables },
    api: { patchCollectionVariables },
  } = useCommand();

  const enableHotkey = getIsActive();

  const [isSaving, setIsSaving] = useState(false);
  const [isSending, setIsSending] = useState(false);

  // @parth: this might be buggy, refer <HttpClientView/>
  const [graphQLRequestExecutor, setGraphQLRequestExecutor] = useState<GraphQLRequestExecutor | null>(null);
  const autoGeneratedStore = useContext(AutogenerateStoreContext);
  const apiClientFilesStore = useContext(ApiClientFilesContext);

  const [error, setError] = useState<RQAPI.ExecutionError | undefined>(undefined);
  const [warning, setWarning] = useState<RQAPI.ExecutionWarning | undefined>(undefined);
  const [isRequestCancelled, setIsRequestCancelled] = useState(false);
  const [isRequestFailed, setIsRequestFailed] = useState(false);

  const originalRecord = useRef(getRecord().data);
  const isHistoryView = location.pathname.includes(PATHS.API_CLIENT.HISTORY.RELATIVE);

  const scopedVariables = useScopedVariables(recordId);

  const handleUrlChange = useCallback(
    (value: string) => {
      updateRecordRequest({
        url: value,
      });
    },
    [updateRecordRequest]
  );

  const { introspectAndSaveSchema } = useGraphQLIntrospection();
  const [purgeAndAddHeaders] = useAutogenerateStore((state) => [state.purgeAndAddHeaders]);

  const debouncedIntrospection = useDebounce(introspectAndSaveSchema, 500);

  useEffect(() => {
    if (url && isNull(introspectionData)) {
      debouncedIntrospection();
    }
  }, [url, debouncedIntrospection, introspectionData]);

  const handleUrlInputEnterPressed = useCallback((evt: KeyboardEvent) => {
    (evt.target as HTMLInputElement).blur();
  }, []);

  useEffect(() => {
    purgeAndAddHeaders(AutogeneratedFieldsNamespace.CONTENT_TYPE, {
      "Content-Type": createHeaderEntry("Content-Type", RequestContentType.JSON),
    });
  }, [purgeAndAddHeaders]);

  const handleSave = useCallback(async () => {
    const apiRecord = getRecord();

    const recordToSave: Partial<RQAPI.ApiRecord> = {
      type: RQAPI.RecordType.API,
      data: {
        ...apiRecord.data,
      },
    };
    if (isCreateMode) {
      const requestId = apiClientRecordsRepository.generateApiRecordId();
      recordToSave.id = requestId;
    }

    if (apiRecord?.id) {
      recordToSave.id = apiRecord?.id;
    }
    setIsSaving(true);
    const result = isCreateMode
      ? await apiClientRecordsRepository.createRecordWithId(recordToSave, recordToSave.id)
      : await apiClientRecordsRepository.updateRecord(recordToSave, recordToSave.id);

    if (result.success && result.data.type === RQAPI.RecordType.API) {
      onSaveRecord({ ...(apiRecord ?? {}), ...result.data, data: { ...result.data.data, ...recordToSave.data } });
      onSaveCallback(result.data as RQAPI.GraphQLApiRecord);
      setHasUnsavedChanges(false);
      toast.success("Request saved!");
    } else {
      toast.error("Something went wrong while saving the request");
    }
    setIsSaving(false);
  }, [onSaveCallback, getRecord, isCreateMode, apiClientRecordsRepository, onSaveRecord, setHasUnsavedChanges]);

  const handleRevertChanges = () => {
    updateRecord(originalRecord.current);
  };

  const resetState = useCallback(() => {
    setError(undefined);
    setWarning(undefined);
    setIsRequestCancelled(false);
    setIsRequestFailed(false);
    updateRecordResponse(null);
  }, [updateRecordResponse]);

  const handleSend = useCallback(async () => {
    const record = getRecord();
    try {
      if (!record) {
        throw new Error("Record not found");
      }

      resetState();
      setIsSending(true);

      const apiClientExecutionResult = await graphQLRequestExecutor.executeGraphQLRequest(record);

      const entryWithResponse = apiClientExecutionResult.executedEntry as RQAPI.GraphQLApiEntry;
      updateRecordResponse(entryWithResponse.response);
      updateRecordTestResults(entryWithResponse.testResults ?? []);
      notifyApiRequestFinished(entryWithResponse);

      if (apiClientExecutionResult.status === RQAPI.ExecutionStatus.SUCCESS) {
        if (apiClientExecutionResult.warning) {
          setWarning(apiClientExecutionResult.warning);
        }
      } else if (apiClientExecutionResult.status === RQAPI.ExecutionStatus.ERROR) {
        setError(apiClientExecutionResult.error);
        setIsRequestFailed(true);
      }

      toast.success("Request executed successfully");
    } catch (error) {
      setIsRequestFailed(true);
      setError(error as RQAPI.ExecutionError);
      toast.error("Something went wrong while sending the request");
    } finally {
      setIsSending(false);
    }
  }, [
    getRecord,
    resetState,
    graphQLRequestExecutor,
    updateRecordResponse,
    updateRecordTestResults,
    notifyApiRequestFinished,
  ]);

  const handleTestResultRefresh = useCallback(async () => {
    try {
      graphQLRequestExecutor.prepareGraphQLRequest(getRecord());

      const result = await graphQLRequestExecutor.rerun();
      if (result.status === RQAPI.ExecutionStatus.SUCCESS) {
        updateRecordTestResults(result.artifacts.testResults);
      } else {
        setError(result.error);
      }
    } catch (error) {
      toast.error("Something went wrong while refreshing test results");
    }
  }, [graphQLRequestExecutor, getRecord, updateRecordTestResults]);

  const handleUpdatesFromExecutionWorker = useCallback(
    async (state: any) => {
      for (const key in state) {
        if (key === "environment") {
          const activeEnvironment = getActiveEnvironment();
          if (activeEnvironment) {
            await patchEnvironmentVariables({ environmentId: activeEnvironment.id, variables: state[key] });
          }
        }

        if (key === "global") {
          const globalEnvId = environmentVariablesRepository.getGlobalEnvironmentId();
          await patchEnvironmentVariables({ environmentId: globalEnvId, variables: state[key] });
        }

        if (key === "collectionVariables") {
          if (!collectionId) {
            return;
          }

          await patchCollectionVariables({
            collectionId,
            variables: state[key],
          });
        }
      }
    },
    [
      getActiveEnvironment,
      patchEnvironmentVariables,
      environmentVariablesRepository,
      patchCollectionVariables,
      collectionId,
    ]
  );

  const handleCancelRequest = useCallback(() => {
    graphQLRequestExecutor.abort();
    setIsRequestCancelled(true);
  }, [graphQLRequestExecutor]);

  useEffect(() => {
    setIcon(<GrGraphQl />);
  }, [setIcon]);

  useEffect(() => {
    if (isHistoryView) {
      setTitle("History");
    } else {
      setTitle(getRecordName() || "Untitled request");
    }
  }, [setTitle, isHistoryView, getRecordName]);

  useEffect(() => {
    if (graphQLRequestExecutor) {
      graphQLRequestExecutor.updateInternalFunctions({
        postScriptExecutionCallback: handleUpdatesFromExecutionWorker,
      });
    }
  }, [handleUpdatesFromExecutionWorker, graphQLRequestExecutor]);

  useEffect(() => {
    setUnsaved(hasUnsavedChanges);
  }, [hasUnsavedChanges, setUnsaved]);

  // @parth: this might be buggy, refer <HttpClientView/>
  useEffect(() => {
    if (!graphQLRequestExecutor) {
      setGraphQLRequestExecutor(
        new GraphQLRequestExecutor(
          recordId,
          ctx,
          appMode,
          apiClientWorkloadManager,
          autoGeneratedStore,
          apiClientFilesStore
        )
      );
    }
  }, [
    apiClientWorkloadManager,
    ctx,
    recordId,
    appMode,
    graphQLRequestExecutor,
    autoGeneratedStore,
    apiClientFilesStore,
  ]);

  const isDefaultPlacementRef = useRef(false);
  useLayoutEffect(() => {
    if (isDefaultPlacementRef.current) {
      return;
    }

    isDefaultPlacementRef.current = true;
    const bottomSheetPlacement = window.innerWidth < 1600 ? BottomSheetPlacement.BOTTOM : BottomSheetPlacement.RIGHT;
    toggleSheetPlacement(bottomSheetPlacement);
  }, [toggleSheetPlacement]);

  return (
    <div className="api-client-view gql-client-view">
      <div className="api-client-header-container">
        <RoleBasedComponent
          permission="create"
          resource="api_client_request"
          fallback={
            <Conditional condition={user.loggedIn && !openInModal && hasUnsavedChanges}>
              <RevertViewModeChangesAlert
                title="As a viewer, You can modify and test APIs, but cannot save updates."
                callback={handleRevertChanges}
              />
            </Conditional>
          }
        />
        <div className="api-client-header-container__header">
          <div className="api-client-breadcrumb-container">
            <ApiClientBreadCrumb
              openInModal={openInModal}
              name={getRecordName()}
              OnRecordNameUpdate={() => {}}
              onBlur={() => {}}
            />

            <ClientCodeButton
              handleOnClick={() => {
                graphQLRequestExecutor.prepareGraphQLRequest(getRecord());
              }}
              apiClientExecutor={graphQLRequestExecutor}
            />
          </div>

          <div className="api-client-header__url">
            <Space.Compact className="api-client-url-container">
              <GraphQLClientUrl
                url={url}
                currentEnvironmentVariables={scopedVariables}
                onEnterPress={handleUrlInputEnterPressed}
                onUrlChange={handleUrlChange}
                fetchingIntrospectionData={isFetchingIntrospectionData}
                isIntrospectionDataFetchingFailed={hasIntrospectionFailed}
              />
            </Space.Compact>
            <RQButton
              showHotKeyText
              onClick={() => handleSend()}
              hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SEND_REQUEST.hotKey}
              type="primary"
              className="text-bold"
              disabled={!url}
              loading={isSending}
            >
              Send
            </RQButton>

            <Conditional condition={!openInModal}>
              <RBACButton
                disabled={!hasUnsavedChanges}
                permission="create"
                resource="api_client_request"
                showHotKeyText
                hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SAVE_REQUEST.hotKey}
                onClick={handleSave}
                loading={isSaving}
                tooltipTitle="Saving is not allowed in view-only mode. You can update and view changes but cannot save them."
                enableHotKey={enableHotkey}
              >
                Save
              </RBACButton>
            </Conditional>
          </div>
        </div>
      </div>
      {/* TODO: update props when integrating execution adapter */}
      <BottomSheetLayout
        layout={SheetLayout.SPLIT}
        bottomSheet={
          <ApiClientBottomSheet
            key={recordId}
            response={response}
            testResults={testResults}
            isLoading={isSending}
            isFailed={isRequestFailed}
            isRequestCancelled={isRequestCancelled}
            onCancelRequest={handleCancelRequest}
            handleTestResultRefresh={handleTestResultRefresh}
            error={error}
            onDismissError={resetState}
            warning={warning}
            executeRequest={handleSend}
          />
        }
        minSize={sheetPlacement === BottomSheetPlacement.BOTTOM ? 25 : 350}
        initialSizes={sheetPlacement === BottomSheetPlacement.BOTTOM ? [60, 40] : [60, 40]}
      >
        <div className="api-client-body">
          <GraphQLRequestTabs requestId={recordId} />
        </div>
      </BottomSheetLayout>
    </div>
  );
};

const WithGraphQLRecordProvider = (Component: React.ComponentType<any>) => {
  return (props: any) => {
    return (
      <GraphQLRecordProvider record={props.apiEntryDetails}>
        <Component {...props} />
      </GraphQLRecordProvider>
    );
  };
};

export default WithGraphQLRecordProvider(GraphQLClientView);
