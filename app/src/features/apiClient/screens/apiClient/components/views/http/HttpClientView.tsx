import { SPAN_STATUS_ERROR, SPAN_STATUS_OK } from "@sentry/core";
import * as Sentry from "@sentry/react";
import { isExtensionInstalled } from "actions/ExtensionActions";
import { notification, Select, Space } from "antd";
import { Conditional } from "components/common/Conditional";
import ExtensionDeactivationMessage from "components/misc/ExtensionDeactivationMessage";
import { BottomSheetLayout, useBottomSheetContext } from "componentsV2/BottomSheet";
import { BottomSheetPlacement, SheetLayout } from "componentsV2/BottomSheet/types";
import { NativeError } from "errors/NativeError";
import { useAISessionContext } from "features/ai/contexts/AISession";
import ErrorBoundary from "features/apiClient/components/ErrorBoundary/ErrorBoundary";
import { UserAbortError } from "features/apiClient/errors/UserAbortError/UserAbortError";
import { ApiClientRepositoryInterface } from "features/apiClient/helpers/modules/sync/interfaces";
import {
  buildAutogeneratedTestsBlock,
  hasTests,
  injectAutogeneratedTests,
} from "features/apiClient/helpers/testGeneration/buildPostResponseTests";
import { useHttpRequestExecutor } from "features/apiClient/hooks/requestExecutors/useHttpRequestExecutor";
import {
  ApiClientStore,
  bufferActions,
  bufferAdapterSelectors,
  useApiClientRepository,
  useApiClientStore,
} from "features/apiClient/slices";
import { useSaveBuffer } from "features/apiClient/slices/buffer/hooks";
import { BufferedHttpRecordEntity, useIsBufferDirty } from "features/apiClient/slices/entities";
import { useApiClientSelector } from "features/apiClient/slices/hooks/base.hooks";
import { RBACButton, RevertViewModeChangesAlert, RoleBasedComponent } from "features/rbac";
import { useDeepLinkState } from "hooks";
import { useHostContext } from "hooks/useHostContext";
import { RQButton } from "lib/design-system-v2/components";
import lodash from "lodash";
import {
  trackAPIRequestCancelled,
  trackApiRequestDone,
  trackAPIRequestSent,
  trackInstallExtensionDialogShown,
  trackRequestFailed,
  trackRequestSaved,
  trackResponseLoaded,
  trackTestGenerationCompleted,
  trackTestGenerationFailed,
  trackTestGenerationStarted,
} from "modules/analytics/events/features/apiClient";
import { API_CLIENT } from "modules/analytics/events/features/constants";
import React, { useCallback, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { getAppMode, getIsExtensionEnabled } from "store/selectors";
import { globalActions } from "store/slices/global/slice";
import { getUserAuthDetails } from "store/slices/global/user/selectors";
import { trackRQDesktopLastActivity, trackRQLastActivity } from "utils/AnalyticsUtils";
import { isDesktopMode } from "utils/AppUtils";
import { wrapWithCustomSpan } from "utils/sentry";
import { toast } from "utils/Toast";
import { KEYBOARD_SHORTCUTS } from "../../../../../../../constants/keyboardShortcuts";
import { INVALID_KEY_CHARACTERS } from "../../../../../constants";
import { RequestContentType, RequestMethod, RQAPI } from "../../../../../types";
import {
  checkForLargeFiles,
  getContentTypeFromResponseHeaders,
  getRequestTypeForAnalyticEvent,
  sanitizeEntry,
} from "../../../utils";
import { ApiClientBreadCrumb, BreadcrumbType } from "../components/ApiClientBreadCrumb/ApiClientBreadCrumb";
import { ClientCodeButton } from "../components/ClientCodeButton/ClientCodeButton";
import { Authorization } from "../components/request/components/AuthorizationView/types/AuthConfig";
import { ApiClientBottomSheet } from "../components/response/ApiClientBottomSheet/ApiClientBottomSheet";
import HttpApiClientUrl from "./components/HttpClientUrl/HttpClientUrl";
import HttpRequestTabs, { RequestTab } from "./components/HttpRequestTabs/HttpRequestTabs";
import "./httpClientView.scss";

function getEntry(entity: BufferedHttpRecordEntity, store: ApiClientStore) {
  return entity.getEntityFromState(store.getState()).data;
}

const requestMethodOptions = Object.values(RequestMethod).map((method) => ({
  value: method,
  label: method,
}));

export type HttpClientViewProps = {
  entity: BufferedHttpRecordEntity;
  override?: {
    handleNameChange?: (name: string) => Promise<void>;
    onSaveClick?: {
      save: (record: RQAPI.HttpApiRecord, repositories: ApiClientRepositoryInterface) => Promise<RQAPI.HttpApiRecord>;
      onSuccess: (record: RQAPI.HttpApiRecord) => void;
    };
  };
  openInModal?: boolean;
  notifyApiRequestFinished: (apiEntry: RQAPI.HttpApiEntry) => void;
};

const HttpClientView: React.FC<HttpClientViewProps> = ({
  openInModal = false,
  notifyApiRequestFinished,
  entity,
  override,
}) => {
  const dispatch = useDispatch();
  const appMode = useSelector(getAppMode);
  const isExtensionEnabled = useSelector(getIsExtensionEnabled);
  const user = useSelector(getUserAuthDetails);

  const [, setDeepLinkState] = useDeepLinkState({ tab: RequestTab.QUERY_PARAMS });

  const { toggleBottomSheet, sheetPlacement } = useBottomSheetContext();

  const { getIsActive } = useHostContext();

  const { apiClientRecordsRepository, repoType } = useApiClientRepository();

  const { endAISession } = useAISessionContext();

  const [isFailed, setIsFailed] = useState(false);
  const [isGeneratingTests, setIsGeneratingTests] = useState(false);
  const [scriptEditorVersion, setScriptEditorVersion] = useState(0);

  const [focusPostResponseScriptEditor, setFocusPostResponseScriptEditor] = useState(false);
  const [error, setError] = useState<RQAPI.ExecutionError | null>(null);
  const [warning, setWarning] = useState<RQAPI.ExecutionWarning | null>(null);
  const [isRequestSaving, setIsRequestSaving] = useState(false);
  const [isLoadingResponse, setIsLoadingResponse] = useState(false);
  const [isLongRequest, setIsLongRequest] = useState(false);
  const [isRequestCancelled, setIsRequestCancelled] = useState(false);

  const store = useApiClientStore();

  const hasUnsavedChanges = useIsBufferDirty({
    type: "bufferId",
    bufferId: entity.id,
  });
  // const collectionId = useApiClientSelector(s => entity.getCollectionId(s));
  const url = useApiClientSelector((s) => entity.getUrl(s));
  const contentType = useApiClientSelector((s) => entity.getContentType(s));
  const method = useApiClientSelector((s) => entity.getMethod(s));
  const name = useApiClientSelector((s) => entity.getName(s));
  const isNew = useApiClientSelector((s) => bufferAdapterSelectors.selectById(s.buffer, entity.id)?.isNew);

  const saveBuffer = useSaveBuffer();

  const httpRequestExecutor = useHttpRequestExecutor(entity.meta.referenceId);

  const handleGenerateTests = useCallback(async () => {
    const entry = getEntry(entity, store);
    const { response, request, scripts } = entry;
    if (!response || isGeneratingTests) {
      return;
    }

    setIsGeneratingTests(true);
    trackTestGenerationStarted({
      src: "test_tab_response_panel",
    });
    const method = request.method;
    const status = response.status;

    let hasJsonObjectBody = false;
    try {
      const contentType = getContentTypeFromResponseHeaders(response.headers) ?? "";
      const isJson = /application\/json/i.test(contentType);
      if (isJson) {
        const parsed = JSON.parse(response.body || "null");
        hasJsonObjectBody = parsed && typeof parsed === "object" && !Array.isArray(parsed);
      }
    } catch {
      hasJsonObjectBody = false;
    }

    try {
      const existingScript = scripts?.postResponse || "";
      if (hasTests(existingScript)) {
        setIsGeneratingTests(false);
        return;
      }
      const block = buildAutogeneratedTestsBlock({
        method,
        status,
        hasJsonObjectBody,
      });

      setFocusPostResponseScriptEditor(true);
      const newScript = injectAutogeneratedTests(existingScript, block);

      entity.setPostResponseScript(newScript);

      setScriptEditorVersion((prev) => prev + 1);
      setDeepLinkState({ tab: RequestTab.SCRIPTS });
      trackTestGenerationCompleted({
        src: "test_tab_response_panel",
      });
    } catch {
      toast.error("Something went wrong while generating tests");
      trackTestGenerationFailed({
        src: "test_tab_response_panel",
      });
    } finally {
      setIsGeneratingTests(false);
    }
  }, [isGeneratingTests, setDeepLinkState, entity, store]);

  const onSendButtonClick = useCallback(
    async () =>
      wrapWithCustomSpan(
        {
          name: "[Transaction] api_client.send",
          op: "api_client.send",
          forceTransaction: true,
          attributes: {},
        },
        async () => {
          // updateTab(apiEntryDetails?.id, { isPreview: false });

          const entry = getEntry(entity, store);

          if (!entry.request.url) {
            return;
          }
          if (!isExtensionInstalled() && !isDesktopMode()) {
            /* SHOW INSTALL EXTENSION MODAL */
            const modalProps = {
              heading: "Install browser Extension to use the API Client",
              subHeading:
                "A minimalistic API Client for front-end developers to test their APIs and fast-track their web development lifecycle. Add custom Headers and Query Params to test your APIs.",
              eventPage: "api_client",
            };
            dispatch(globalActions.toggleActiveModal({ modalName: "extensionModal", newProps: modalProps }));
            trackInstallExtensionDialogShown({ src: "api_client" });
            Sentry.getActiveSpan()?.setStatus({
              code: SPAN_STATUS_OK,
            });
            return;
          }

          toggleBottomSheet({ isOpen: true, action: "on_send_request_bottom_sheet" });

          setIsFailed(false);
          setError(null);
          setWarning(null);
          setIsLoadingResponse(true);
          setIsRequestCancelled(false);
          setIsLongRequest(false);

          const hasLargeFiles = entry.request.body ? checkForLargeFiles(entry.request.body) : false;

          const longRequestTimer = setTimeout(() => {
            if (hasLargeFiles) {
              setIsLongRequest(true);
            }
          }, 5000);

          const requestToSend = sanitizeEntry(entry);

          trackAPIRequestSent({
            has_scripts: Boolean(entry?.scripts?.preRequest),
            auth_type: entry?.auth?.currentAuthType,
            request_type: getRequestTypeForAnalyticEvent(false, entry?.request?.url),
            request_body_type: entry?.request?.contentType,
            type: RQAPI.ApiEntryType.HTTP,
          });

          try {
            const apiClientExecutionResult = await httpRequestExecutor.execute(
              {
                entry: requestToSend,
                recordId: entity.meta.referenceId,
              },
              {
                iteration: 0,
                iterationCount: 1,
              }
            );

            const executedEntry = apiClientExecutionResult.executedEntry as RQAPI.HttpApiEntry;
            entity.setResponse(executedEntry.response);
            entity.setTestResults(executedEntry.testResults);

            if (apiClientExecutionResult.status === "success" && executedEntry.response) {
              if (apiClientExecutionResult.warning) {
                setWarning(apiClientExecutionResult.warning);
              }
              trackResponseLoaded({
                type: getContentTypeFromResponseHeaders(executedEntry.response.headers),
                time: Math.round(executedEntry.response.time / 1000),
              });
              trackApiRequestDone({
                url: executedEntry.request.url,
                method: executedEntry.request.method,
                status: executedEntry.response.status,
              });
              trackRQLastActivity(API_CLIENT.RESPONSE_LOADED);
              trackRQDesktopLastActivity(API_CLIENT.RESPONSE_LOADED);
              Sentry.getActiveSpan()?.setStatus({
                code: SPAN_STATUS_OK,
              });
            } else if (apiClientExecutionResult.status === "error") {
              const { error } = apiClientExecutionResult;
              setIsFailed(true);
              setError(error ?? null);
              // Not the best way to handle this. But works for now.
              if (error?.name === UserAbortError.name) {
                Sentry.getActiveSpan()?.setStatus({
                  code: SPAN_STATUS_OK,
                });
                return;
              }

              if (error) {
                Sentry.withScope((scope) => {
                  scope.setTag("error_type", "api_request_failure");
                  scope.setContext("request_details", {
                    url: executedEntry.request.url,
                    method: executedEntry.request.method,
                    headers: executedEntry.request.headers,
                    queryParams: executedEntry.request.queryParams,
                  });
                  scope.setFingerprint(["api_request_error", executedEntry.request.method, error.source]);
                  const sentryError = new Error(
                    `API Request Failed: ${error.message || error.name || "Unknown error"}`
                  );
                  if (error.stack) {
                    sentryError.stack = error.stack;
                  }
                  Sentry.captureException(sentryError);
                });
              }
              trackRequestFailed(
                error.message,
                error.type,
                executedEntry.request.url,
                executedEntry.request.method,
                executedEntry.response?.status
              );
              trackRQLastActivity(API_CLIENT.REQUEST_FAILED);
              trackRQDesktopLastActivity(API_CLIENT.REQUEST_FAILED);
              Sentry.getActiveSpan()?.setStatus({
                code: SPAN_STATUS_ERROR,
              });
            }

            notifyApiRequestFinished(executedEntry);
          } catch (e) {
            setIsFailed(true);
            setError({
              type: e.type,
              source: "request",
              name: e.name,
              message: e.message,
            });
            Sentry.captureException(e);
            Sentry.getActiveSpan()?.setStatus({
              code: SPAN_STATUS_ERROR,
            });
          } finally {
            clearTimeout(longRequestTimer);
            setIsLoadingResponse(false);
            setIsLongRequest(false);
            endAISession();
          }
          trackRQLastActivity(API_CLIENT.REQUEST_SENT);
          trackRQDesktopLastActivity(API_CLIENT.REQUEST_SENT);
        }
      )(),
    [entity, store, toggleBottomSheet, dispatch, httpRequestExecutor, notifyApiRequestFinished, endAISession]
  );

  const handleDismissError = () => {
    setError(null);
    setIsFailed(false);
    setIsLoadingResponse(false);
    setIsRequestCancelled(false);
  };

  const handleRecordNameUpdate = useCallback(
    async (name: string) => {
      const record = lodash.cloneDeep(entity.getEntityFromState(store.getState()));
      record.name = name;
      const result = await apiClientRecordsRepository.updateRecord(record, entity.meta.referenceId);
      if (!result.success) {
        notification.error({
          message: "Could not rename record",
          description: result?.message,
          placement: "bottomRight",
        });
        return;
      }
      entity.origin.setName(name);
    },
    [entity, apiClientRecordsRepository, store]
  );

  const onSaveButtonClick = useCallback(async () => {
    return wrapWithCustomSpan(
      {
        name: "[Transaction] api_client.save",
        op: "api_client.save",
        forceTransaction: true,
        attributes: {
          "_attribute.is_create_mode": isNew,
          "_attribute.workspace_type": repoType,
        },
      },
      async () => {
        saveBuffer(
          {
            entity,
            skipMarkSaved: override?.onSaveClick?.skipMarkSaved,
            produceChanges(entity, state) {
              const record = lodash.cloneDeep(entity.getEntityFromState(state));
              record.data = sanitizeEntry(record.data);
              const entry = record.data;

              const isValidHeader = entry.request?.headers?.every((header) => {
                return !header.isEnabled || !INVALID_KEY_CHARACTERS.test(header.key);
              });

              const isValidAuthKey =
                entry.auth?.currentAuthType !== Authorization.Type.API_KEY ||
                !entry.auth?.authConfigStore?.API_KEY?.key ||
                !INVALID_KEY_CHARACTERS.test(entry.auth?.authConfigStore?.API_KEY?.key) ||
                entry.auth?.authConfigStore?.API_KEY.addTo === "QUERY";

              if (!isValidHeader || !isValidAuthKey) {
                throw new NativeError("Request contains invalid characters!");
              }

              const base = entry.request.url.split("?")[0];
              if (base) {
                entry.request.url = base;
              }

              return record;
            },
            async save(record, repositories) {
              if (override?.onSaveClick) {
                return override.onSaveClick.save(record, repositories);
              }
              const result = await repositories.apiClientRecordsRepository.updateRecord(record, record.id);
              if (!result.success) {
                throw new NativeError(result.message || "Could not save request!");
              }
              return result.data as RQAPI.HttpApiRecord;
            },
          },
          {
            beforeSave() {
              setIsRequestSaving(true);
            },
            afterSave() {
              setIsRequestSaving(false);
              endAISession();
            },
            onSuccess(result) {
              toast.success("Request saved!");
              override?.onSaveClick?.onSuccess(result);
              trackRequestSaved({
                src: "api_client_view",
                has_scripts: Boolean(result.data.scripts?.preRequest),
                auth_type: result?.data.auth?.currentAuthType,
                type: RQAPI.ApiEntryType.HTTP,
              });
              Sentry.getActiveSpan()?.setStatus({
                code: SPAN_STATUS_OK,
              });
            },
            onError(e) {
              notification.error({
                message: `Could not save request.`,
                description: e.message,
                placement: "bottomRight",
              });
              Sentry.captureException(e);
              Sentry.getActiveSpan()?.setStatus({
                code: SPAN_STATUS_ERROR,
                // message: "invalid_auth_header", // This somehow is breaking the status of the span on sentry. Comes as unknown if set
              });
            },
          }
        );
      }
    )();
    // Little bit weird syntax but we need to call function to actually execute the wrapped function
  }, [entity, override, saveBuffer, isNew, repoType, endAISession, setIsRequestSaving]);

  const handleCancelRequest = useCallback(() => {
    httpRequestExecutor.abort();
    trackAPIRequestCancelled();
    setIsRequestCancelled(true);
  }, [httpRequestExecutor]);

  const handleAuthChange = useCallback(
    (newAuth: RQAPI.Auth) => {
      entity.setAuth(newAuth);
    },
    [entity]
  );

  const onUrlInputEnterPressed = useCallback((evt: KeyboardEvent) => {
    (evt.target as HTMLInputElement).blur();
  }, []);

  const handleTestResultRefresh = useCallback(async () => {
    try {
      const result = await httpRequestExecutor.rerun(entity.meta.referenceId, getEntry(entity, store));
      if (result.status === RQAPI.ExecutionStatus.SUCCESS) {
        entity.setTestResults(result.artifacts.testResults);
      } else {
        setError(result.error);
      }
    } catch {
      toast.error("Something went wrong while refreshing test results");
    }
  }, [httpRequestExecutor, entity, store]);

  const handleRevertChanges = useCallback(() => {
    if (!entity.meta.originExists) {
      return; // Can't revert if there's no origin
    }
    const originState = entity.origin.getEntityFromState(store.getState());
    store.dispatch(
      bufferActions.revertChanges({
        referenceId: entity.meta.referenceId!,
        sourceData: originState,
      })
    );
  }, [entity, store]);

  const enableHotkey = getIsActive();

  return isExtensionEnabled ? (
    <div className="api-client-view http-client-view">
      <div className="api-client-header-container">
        <RoleBasedComponent
          permission="create"
          resource="api_client_request"
          fallback={
            <Conditional condition={user.loggedIn && !openInModal && hasUnsavedChanges}>
              <RevertViewModeChangesAlert
                title="As a viewer, You can modify and test APIs, but cannot save updates."
                callback={handleRevertChanges}
              />
            </Conditional>
          }
        />
        <div className="api-client-header-container__header">
          <div className="api-client-breadcrumb-container">
            <ApiClientBreadCrumb
              isDraft={!!isNew}
              id={entity.meta.referenceId}
              openInModal={openInModal}
              placeholder="Untitled request"
              name={name}
              autoFocus={isNew}
              onBlur={(name) => {
                if (override?.handleNameChange) {
                  override.handleNameChange(name);
                  return;
                }
                handleRecordNameUpdate(name);
              }}
              breadCrumbType={BreadcrumbType.API_REQUEST}
            />

            <ClientCodeButton
              requestPreparer={() => {
                const entry = entity.getEntityFromState(store.getState()).data;
                return httpRequestExecutor.requestPreparer.prepareRequest(entity.meta.referenceId, entry).preparedEntry
                  .request;
              }}
            />
          </div>

          <div className="api-client-header__url">
            <Space.Compact className="api-client-url-container">
              <Select
                popupClassName="api-request-method-selector"
                className="api-request-method-selector"
                options={requestMethodOptions}
                value={method}
                onChange={entity.setMethod.bind(entity)}
              />
              <HttpApiClientUrl
                entity={entity}
                onUrlChange={entity.setUrl.bind(entity)}
                onEnterPress={onUrlInputEnterPressed}
              />
            </Space.Compact>
            <RQButton
              showHotKeyText
              onClick={onSendButtonClick}
              hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SEND_REQUEST!.hotKey}
              type="primary"
              className="text-bold"
              enableHotKey={enableHotkey}
              disabled={!url || (appMode === "EXTENSION" && contentType === RequestContentType.MULTIPART_FORM)}
            >
              Send
            </RQButton>

            <Conditional condition={!openInModal}>
              <RBACButton
                disabled={
                  !hasUnsavedChanges || (appMode === "EXTENSION" && contentType === RequestContentType.MULTIPART_FORM)
                }
                permission="create"
                resource="api_client_request"
                showHotKeyText
                hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SAVE_REQUEST!.hotKey}
                onClick={onSaveButtonClick}
                loading={isRequestSaving}
                tooltipTitle="Saving is not allowed in view-only mode. You can update and view changes but cannot save them."
                enableHotKey={enableHotkey}
              >
                Save
              </RBACButton>
            </Conditional>
          </div>
        </div>
      </div>
      <BottomSheetLayout
        layout={SheetLayout.SPLIT}
        bottomSheet={
          <ApiClientBottomSheet
            entity={entity}
            onGenerateTests={handleGenerateTests}
            isGeneratingTests={isGeneratingTests}
            isLoading={isLoadingResponse}
            isFailed={isFailed}
            isLongRequest={isLongRequest}
            isRequestCancelled={isRequestCancelled}
            onCancelRequest={handleCancelRequest}
            handleTestResultRefresh={handleTestResultRefresh}
            error={error}
            onDismissError={handleDismissError}
            warning={warning}
            executeRequest={onSendButtonClick}
          />
        }
        initialSizes={sheetPlacement === BottomSheetPlacement.BOTTOM ? [60, 40] : [50, 50]}
      >
        <div
          className={`api-client-body ${
            sheetPlacement === BottomSheetPlacement.BOTTOM ? "api-client-body__vertical" : "api-client-body__horizontal"
          }`}
        >
          <HttpRequestTabs
            error={error}
            entity={entity}
            handleAuthChange={handleAuthChange}
            focusPostResponseScriptEditor={focusPostResponseScriptEditor}
            scriptEditorVersion={scriptEditorVersion}
          />
        </div>
      </BottomSheetLayout>
    </div>
  ) : (
    <div className="w-full">
      <ExtensionDeactivationMessage />
    </div>
  );
};

const WithErrorBoundary = (Component: React.ComponentType<any>): React.FC<HttpClientViewProps> => {
  const WrappedComponent: React.FC = (props: any) => {
    return (
      <ErrorBoundary boundaryId="http-client-view-error-boundary">
        <Component {...props} />
      </ErrorBoundary>
    );
  };

  return WrappedComponent;
};

export default React.memo(WithErrorBoundary(HttpClientView));
