import lodash from 'lodash';
import React, { useCallback, useEffect, useLayoutEffect, useState, useMemo } from "react";
import { notification, Select, Space } from "antd";
import { useDispatch } from "react-redux";
import * as Sentry from "@sentry/react";
import { KeyValuePair, RQAPI, RequestContentType, RequestMethod } from "../../../../../types";
import {
  hasTests,
  buildAutogeneratedTestsBlock,
  injectAutogeneratedTests,
} from "features/apiClient/helpers/testGeneration/buildPostResponseTests";
import {
  checkForLargeFiles,
  getContentTypeFromResponseHeaders,
  getEmptyApiEntry,
  getRequestTypeForAnalyticEvent,
  parseHttpRequestEntry,
  resolveAuth,
  sanitizeEntry,
  supportsRequestBody,
} from "../../../utils";
import { isExtensionInstalled } from "actions/ExtensionActions";
import {
  trackAPIRequestCancelled,
  trackRequestFailed,
  trackResponseLoaded,
  trackInstallExtensionDialogShown,
  trackRequestSaved,
  trackRequestRenamed,
  trackApiRequestDone,
  trackAPIRequestSent,
  trackTestGenerationStarted,
  trackTestGenerationCompleted,
  trackTestGenerationFailed,
} from "modules/analytics/events/features/apiClient";
import { useSelector } from "react-redux";
import { globalActions } from "store/slices/global/slice";
import { getAppMode, getIsExtensionEnabled } from "store/selectors";
import { getUserAuthDetails } from "store/slices/global/user/selectors";
import { CONTENT_TYPE_HEADER, INVALID_KEY_CHARACTERS } from "../../../../../constants";
import ExtensionDeactivationMessage from "components/misc/ExtensionDeactivationMessage";
import { trackRQDesktopLastActivity, trackRQLastActivity } from "utils/AnalyticsUtils";
import { API_CLIENT } from "modules/analytics/events/features/constants";
import { isDesktopMode } from "utils/AppUtils";
import { RQButton } from "lib/design-system-v2/components";
import { toast } from "utils/Toast";
import { BottomSheetLayout, useBottomSheetContext } from "componentsV2/BottomSheet";
import { BottomSheetPlacement, SheetLayout } from "componentsV2/BottomSheet/types";
import { ApiClientBottomSheet } from "../components/response/ApiClientBottomSheet/ApiClientBottomSheet";
import { KEYBOARD_SHORTCUTS } from "../../../../../../../constants/keyboardShortcuts";
import { useDeepLinkState, useHasUnsavedChanges } from "hooks";
import { RBACButton, RevertViewModeChangesAlert, RoleBasedComponent } from "features/rbac";
import { Conditional } from "components/common/Conditional";
import { useGenericState } from "hooks/useGenericState";
import { useQueryParamStore } from "features/apiClient/hooks/useQueryParamStore";
import { useAutogenerateStoreContext } from "features/apiClient/store/autogenerateContextProvider";
import { useAutogenerateStore } from "features/apiClient/hooks/useAutogenerateStore";
import {
  AutogeneratedFieldsNamespace,
  parseAuth,
  SimpleKeyValuePair,
} from "features/apiClient/store/autogenerateStore";
import { useParentApiRecord } from "features/apiClient/hooks/useParentApiRecord.hook";
import { useScopedVariables } from "features/apiClient/helpers/variableResolver/variable-resolver";
import { renderVariables } from "backend/environment/utils";
import HttpApiClientUrl from "./components/HttpClientUrl/HttpClientUrl";
import { ApiClientBreadCrumb, BreadcrumbType } from "../components/ApiClientBreadCrumb/ApiClientBreadCrumb";
import { ClientCodeButton } from "../components/ClientCodeButton/ClientCodeButton";
import HttpRequestTabs, { RequestTab } from "./components/HttpRequestTabs/HttpRequestTabs";
import "./httpClientView.scss";
import { QueryParamsProvider } from "features/apiClient/store/QueryParamsContextProvider";
import { MdOutlineSyncAlt } from "@react-icons/all-files/md/MdOutlineSyncAlt";
import { useAPIRecords, useAPIRecordsStore } from "features/apiClient/store/apiRecords/ApiRecordsContextProvider";
import { Authorization } from "../components/request/components/AuthorizationView/types/AuthConfig";
import ErrorBoundary from "features/apiClient/components/ErrorBoundary/ErrorBoundary";
import { useHttpRequestExecutor } from "features/apiClient/hooks/requestExecutors/useHttpRequestExecutor";
import { PathVariablesProvider } from "features/apiClient/store/pathVariables/PathVariablesContextProvider";
import { usePathVariablesStore } from "features/apiClient/hooks/usePathVariables.store";
import { useAISessionContext } from "features/ai/contexts/AISession";
import { useEntity } from "features/apiClient/slices/entities/hooks";
import { BufferedApiClientEntity, OriginExists } from "features/apiClient/slices/entities/buffered/factory";
import { BufferedHttpRecordEntity, useBufferedEntitySelector, useIsBufferDirty } from "features/apiClient/slices/entities";
import { useApiClientSelector } from "features/apiClient/slices/hooks/base.hooks";
import { bufferAdapterSelectors, useApiClientRepository, useApiClientStore } from 'features/apiClient/slices';
import { saveBulkRecords } from 'features/apiClient/commands/store.utils';
import { useSaveBuffer } from 'features/apiClient/slices/buffer/hooks';
import { NativeError } from 'errors/NativeError';
import { useHostContext } from 'hooks/useHostContext';

const requestMethodOptions = Object.values(RequestMethod).map((method) => ({
  value: method,
  label: method,
}));

type Props = {
  // isCreateMode: boolean;
  // apiEntryDetails: RQAPI.HttpApiRecord;
  entity: BufferedHttpRecordEntity,
  openInModal?: boolean;
  onSaveCallback: (apiEntryDetails: RQAPI.HttpApiRecord) => void;
  notifyApiRequestFinished: (apiEntry: RQAPI.HttpApiEntry) => void;
};

const HttpClientView: React.FC<Props> = ({
  // isCreateMode,
  openInModal = false,
  onSaveCallback,
  notifyApiRequestFinished,
  entity,
}) => {
  const dispatch = useDispatch();
  const appMode = useSelector(getAppMode);
  const isExtensionEnabled = useSelector(getIsExtensionEnabled);
  const user = useSelector(getUserAuthDetails);

  const [, setDeepLinkState] = useDeepLinkState({ tab: RequestTab.QUERY_PARAMS });

  const { toggleBottomSheet, sheetPlacement } = useBottomSheetContext();

  const { getIsActive } = useHostContext();

  // const { onSaveRecord } = useNewApiClientContext();

  // const ctx = useApiClientFeatureContext();

  const repositories = useApiClientRepository();

  const { endAISession } = useAISessionContext();
  // useBufferedEntitySelector({
  //   id: entity.id,
  //   type: entity.type
  // }, (e, s) => e.getAuth)
  const scopedVariables = useScopedVariables(entity.meta.referenceId);

  // const { version: parentVersion } = useParentApiRecord(apiEntryDetails?.id);
  // const getPathVariables = usePathVariablesStore((state) => state.getPathVariables);

  // const [requestName, setRequestName] = useState(apiEntryDetails?.name || "");
  // const [entry, setEntry] = useState<RQAPI.HttpApiEntry>(
  //   apiEntryDetails?.data ?? (getEmptyApiEntry(RQAPI.ApiEntryType.HTTP) as RQAPI.HttpApiEntry)
  // );
  // const setRequestName = useCallback(
  //   (name: string) => {
  //     entity.setName(name);
  //   },
  //   [entity]
  // )

  const [isFailed, setIsFailed] = useState(false);
  const [isGeneratingTests, setIsGeneratingTests] = useState(false);
  const [scriptEditorVersion, setScriptEditorVersion] = useState(0);

  const [focusPostResponseScriptEditor, setFocusPostResponseScriptEditor] = useState(false);
  const [error, setError] = useState<RQAPI.ExecutionError | null>(null);
  const [warning, setWarning] = useState<RQAPI.ExecutionWarning | null>(null);
  const [isRequestSaving, setIsRequestSaving] = useState(false);
  const [isLoadingResponse, setIsLoadingResponse] = useState(false);
  const [isLongRequest, setIsLongRequest] = useState(false);
  const [isRequestCancelled, setIsRequestCancelled] = useState(false);

  const hasUnsavedChanges = useIsBufferDirty({
    type: 'bufferId',
    bufferId: entity.id,
  });
  // const autoGeneratedStore = useAutogenerateStoreContext();

  // const queryParams = useQueryParamStore((state) => state.queryParams);

  // const { setPreview, setUnsaved, setTitle, getIsActive, setIcon, getIsNew, setIsNew } = useGenericState();

  // const { response, testResults = undefined, ...entryWithoutResponse } = entry;

  const store = useApiClientStore();

  const collectionId = useApiClientSelector(s => entity.getCollectionId(s));
  const request = useApiClientSelector(s => entity.getRequest(s));
  const response = useApiClientSelector(s => entity.getResponse(s));
  const postResponseScript = useApiClientSelector(s => entity.getPostResponseScript(s));
  const preRequestScript = useApiClientSelector(s => entity.getPreRequestScript(s));
  const url = useApiClientSelector(s => entity.getUrl(s));
  const queryParams = useApiClientSelector(s => entity.getQueryParams(s));
  const testResults = useApiClientSelector(s => entity.getTestResults(s));
  const name = useApiClientSelector(s => entity.getName(s));
  const isNew = useApiClientSelector(s => bufferAdapterSelectors.selectById(s.buffer, entity.id)?.isNew);

  const saveBuffer = useSaveBuffer();

  // const entry = useApiClientSelector(s => entity.getEntityFromState(s).data);

  const httpRequestExecutor = useHttpRequestExecutor(collectionId);

  const handleGenerateTests = useCallback(async () => {
    if (!response || isGeneratingTests) {
      return;
    }

    setIsGeneratingTests(true);
    trackTestGenerationStarted({
      src: "test_tab_response_panel",
    });
    const method = request.method;
    const status = response.status;

    let hasJsonObjectBody = false;
    try {
      const contentType = getContentTypeFromResponseHeaders(response.headers) ?? "";
      const isJson = /application\/json/i.test(contentType);
      if (isJson) {
        const parsed = JSON.parse(response.body || "null");
        hasJsonObjectBody = parsed && typeof parsed === "object" && !Array.isArray(parsed);
      }
    } catch (_) {
      hasJsonObjectBody = false;
    }

    try {
      const existingScript = postResponseScript || "";
      if (hasTests(existingScript)) {
        setIsGeneratingTests(false);
        return;
      }
      const block = buildAutogeneratedTestsBlock({
        method,
        status,
        hasJsonObjectBody,
      });

      setFocusPostResponseScriptEditor(true);
      const newScript = injectAutogeneratedTests(existingScript, block);

      // setEntry((prev) => ({
      //   ...prev,
      //   scripts: {
      //     preRequest: prev.scripts?.preRequest || "",
      //     postResponse: newScript,
      //   },
      // }));

      entity.setPostResponseScript(newScript);

      setScriptEditorVersion((prev) => prev + 1);
      setDeepLinkState({ tab: RequestTab.SCRIPTS });
      trackTestGenerationCompleted({
        src: "test_tab_response_panel",
      });
    } catch (e) {
      toast.error("Something went wrong while generating tests");
      trackTestGenerationFailed({
        src: "test_tab_response_panel",
      });
    } finally {
      setIsGeneratingTests(false);
    }
  }, [isGeneratingTests, setDeepLinkState]);

  const canGenerateTests = useMemo(() => {
    const responseExists = Boolean(postResponseScript);
    if (!responseExists) return false;
    return !hasTests(postResponseScript);
  }, [postResponseScript]);

  // Passing sanitized entry because response and empty key value pairs are saved in DB
  // const { hasUnsavedChanges, resetChanges } = useHasUnsavedChanges(
  //   sanitizeEntry({ ...entryWithoutResponse, response: null }, false)
  // );

  // const isHistoryView = location.pathname.includes(PATHS.API_CLIENT.HISTORY.RELATIVE);

  // const [purgeAndAdd] = useAutogenerateStore((state) => [state.purgeAndAdd, state.purgeAndAddHeaders]);
  // const [getData, getParentChain] = useAPIRecords((state) => [state.getData, state.getParentChain]);
  // const [purgeAndAdd] = useAutogenerateStore((state) => [state.purgeAndAdd, state.purgeAndAddHeaders]);
  // const [getData, getParentChain] = useAPIRecords((state) => [state.getData, state.getParentChain]);





  // const setMethod = useCallback((method: RequestMethod) => {
  //   if (!supportsRequestBody(method)) {
  //     entity.deleteBody();
  //     entity.setContentType(RequestContentType.RAW);
  //     entity.deleteHeader((header) => header.key !== CONTENT_TYPE_HEADER);
  //   }
  //   entity.setMethod(method);
  //   // setEntry((entry) => {
  //   //   const newEntry: RQAPI.HttpApiEntry = {
  //   //     ...entry,
  //   //     request: {
  //   //       ...entry.request,
  //   //       method,
  //   //     },
  //   //   };

  //   //   if (!supportsRequestBody(method)) {
  //   //     delete newEntry.request.body;
  //   //     newEntry.request.headers = newEntry.request.headers.filter((header) => header.key !== CONTENT_TYPE_HEADER);
  //   //     newEntry.request.contentType = RequestContentType.RAW;
  //   //   }
  //   //   return newEntry;
  //   // });
  // }, []);






  const onSendButtonClick = useCallback(async () => {
    if (!url) {
      return;
    }
    if (!isExtensionInstalled() && !isDesktopMode()) {
      /* SHOW INSTALL EXTENSION MODAL */
      const modalProps = {
        heading: "Install browser Extension to use the API Client",
        subHeading:
          "A minimalistic API Client for front-end developers to test their APIs and fast-track their web development lifecycle. Add custom Headers and Query Params to test your APIs.",
        eventPage: "api_client",
      };
      dispatch(globalActions.toggleActiveModal({ modalName: "extensionModal", newProps: modalProps }));
      trackInstallExtensionDialogShown({ src: "api_client" });
      return;
    }

    toggleBottomSheet({ isOpen: true, action: "on_send_request_bottom_sheet" });

    setIsFailed(false);
    setError(null);
    setWarning(null);
    setIsLoadingResponse(true);
    setIsRequestCancelled(false);
    setIsLongRequest(false);

    const hasLargeFiles = request.body ? checkForLargeFiles(request.body) : false;

    const longRequestTimer = setTimeout(() => {
      if (hasLargeFiles) {
        setIsLongRequest(true);
      }
    }, 5000);

    //Need to change the response and error to null
    // setEntry((entry) => ({
    //   ...entry,
    //   error: null,
    // }));

    // const requestToSend = {
    //   ...entry,
    //   request: {
    //     ...entry.request,
    //     queryParams: queryPa,
    //     pathVariables: getPathVariables(),
    //   },
    // };

    trackAPIRequestSent({
      has_scripts: Boolean(preRequestScript),
      // auth_type: entry?.auth?.currentAuthType,
      // request_type: getRequestTypeForAnalyticEvent(apiEntryDetails?.isExample, entry?.request?.url),
      request_body_type: request?.contentType,
      type: RQAPI.ApiEntryType.HTTP,
    });

    try {
      // const rawEntry = entity.getEntityFromState(store.getState()).data;
      // const entry = sanitizeEntry(lodash.cloneDeep(rawEntry));
      const apiClientExecutionResult = await httpRequestExecutor.execute(
        {
          entity,
          recordId: entity.meta.referenceId,
        },
        {
          iteration: 0,
          iterationCount: 1,
        }
      );

      const executedEntry = apiClientExecutionResult.executedEntry as RQAPI.HttpApiEntry;
      // const entryWithResponse: RQAPI.HttpApiEntry = {
      //   ...entry,
      //   response: executedEntry.response,
      //   testResults: executedEntry.testResults,
      // };
      entity.setResponse(executedEntry.response);
      entity.setTestResults(executedEntry.testResults);
      // setEntry(entryWithResponse);

      if (apiClientExecutionResult.status === "success" && executedEntry.response) {
        if (apiClientExecutionResult.warning) {
          setWarning(apiClientExecutionResult.warning);
        }
        trackResponseLoaded({
          type: getContentTypeFromResponseHeaders(executedEntry.response.headers),
          time: Math.round(executedEntry.response?.time / 1000),
        });
        trackApiRequestDone({
          url: executedEntry.request.url,
          method: executedEntry.request.method,
          status: executedEntry.response.status,
        });
        trackRQLastActivity(API_CLIENT.RESPONSE_LOADED);
        trackRQDesktopLastActivity(API_CLIENT.RESPONSE_LOADED);
      } else if (apiClientExecutionResult.status === "error") {
        const { error } = apiClientExecutionResult;
        setIsFailed(true);
        setError(error ?? null);
        if (error) {
          Sentry.withScope((scope) => {
            scope.setTag("error_type", "api_request_failure");
            scope.setContext("request_details", {
              url: request.url,
              method: request.method,
              headers: request.headers,
              queryParams: request.queryParams,
            });
            scope.setFingerprint(["api_request_error", request.method, error.source]);
            Sentry.captureException(new Error(`API Request Failed: ${error.message || "Unknown error"}`));
          });
        }
        trackRequestFailed(
          error.message,
          error.type,
          request.url,
          request.method,
          response?.status
        );
        trackRQLastActivity(API_CLIENT.REQUEST_FAILED);
        trackRQDesktopLastActivity(API_CLIENT.REQUEST_FAILED);
      }

      notifyApiRequestFinished(executedEntry);
    } catch (e) {
      console.error(e);
      setIsFailed(true);
      setError({
        type: e.type,
        source: "request",
        name: e.name,
        message: e.message,
      });
    } finally {
      clearTimeout(longRequestTimer);
      setIsLoadingResponse(false);
      setIsLongRequest(false);
      endAISession();
    }
    trackRQLastActivity(API_CLIENT.REQUEST_SENT);
    trackRQDesktopLastActivity(API_CLIENT.REQUEST_SENT);
  }, [
    // entry,
    toggleBottomSheet,
    queryParams,
    // apiEntryDetails?.isExample,
    // apiEntryDetails?.id,
    dispatch,
    httpRequestExecutor,
    notifyApiRequestFinished,
    // getPathVariables,
    endAISession,
  ]);

  const handleDismissError = () => {
    setError(null);
    setIsFailed(false);
    setIsLoadingResponse(false);
    setIsRequestCancelled(false);
  };

  const handleRecordNameUpdate = useCallback(async (name: string) => {
    const result = await repositories.apiClientRecordsRepository.updateRecord({ name }, entity.meta.referenceId);
    if (!result.success) {
      notification.error({
        message: "Could not rename record",
        description: result?.message,
        placement: "bottomRight",
      });
      return;
    }
    entity.origin.setName(name);
  }, [entity]);

  const onSaveButtonClick = useCallback(async () => {
    if (!entity.meta.originExists) {
      throw new Error('Can not save a buffer from this flow since there is no origin!');
    }

    saveBuffer(
      {
        entity: entity as OriginExists<typeof entity>,
        produceChanges(entity, state) {
          const record = lodash.cloneDeep(entity.getEntityFromState(state));
          record.data = sanitizeEntry(record.data);
          const entry = record.data;

          const isValidHeader = entry.request?.headers?.every((header) => {
            return !header.isEnabled || !INVALID_KEY_CHARACTERS.test(header.key);
          });

          const isValidAuthKey =
            entry.auth?.currentAuthType !== Authorization.Type.API_KEY ||
            !entry.auth?.authConfigStore?.API_KEY?.key ||
            !INVALID_KEY_CHARACTERS.test(entry.auth?.authConfigStore?.API_KEY?.key) ||
            entry.auth?.authConfigStore?.API_KEY.addTo === "QUERY";

          if (!isValidHeader || !isValidAuthKey) {
            throw new NativeError("Request contains invalid characters!");
          }

          const base = entry.request.url.split("?")[0];
          if (base) {
            entry.request.url = base;
          }

          return record;
        },
        async save(record, repositories, entity) {
          const result = await repositories.apiClientRecordsRepository.updateRecord(record, record.id);
          if (!result.success) {
            throw new NativeError(result.message || "Could not save request!");
          }
        },
      },
      {
        beforeSave() {
          setIsRequestSaving(true);
        },
        afterSave() {
          setIsRequestSaving(false);
        },
        onSuccess(changes, entity) {
          toast.success("Request saved!");
        },
        onError(e) {
          notification.error({
            message: `Could not save request.`,
            description: e.message,
            placement: "bottomRight",
          });
        },
      }
    )


    // const entryToSave = {
    //   ...entry,
    //   request: {
    //     ...entry.request,
    //     url: entry.request.url.split("?")[0],
    //     queryParams: queryParams,
    //     pathVariables: getPathVariables(),
    //   },
    // };
    // const isValidHeader = entry.request?.headers?.every((header) => {
    //   return !header.isEnabled || !INVALID_KEY_CHARACTERS.test(header.key);
    // });

    // const isValidAuthKey =
    //   entry.auth?.currentAuthType !== Authorization.Type.API_KEY ||
    //   !entry.auth?.authConfigStore?.API_KEY?.key ||
    //   !INVALID_KEY_CHARACTERS.test(entry.auth?.authConfigStore?.API_KEY?.key) ||
    //   entry.auth?.authConfigStore?.API_KEY.addTo === "QUERY";

    // if (!isValidHeader || !isValidAuthKey) {
    //   notification.error({
    //     message: `Could not save request.`,
    //     description: "key contains invalid characters.",
    //     placement: "bottomRight",
    //   });
    //   setIsRequestSaving(false);
    //   return;
    // }

    // const record: Partial<RQAPI.ApiRecord> = {
    //   type: RQAPI.RecordType.API,
    //   data: { ...sanitizeEntry(entryToSave, false) },
    // };

    // if (isCreateMode) {
    //   const requestId = apiClientRecordsRepository.generateApiRecordId();
    //   record.id = requestId;
    // }

    // //  Is this check necessary?
    // if (apiEntryDetails?.id) {
    //   record.id = apiEntryDetails?.id;
    // }

    // const result = isCreateMode
    //   ? await apiClientRecordsRepository.createRecordWithId(record, record.id!) // not the ideal way but had to assert because record is typed as Partial here
    //   : await apiClientRecordsRepository.updateRecord(record, record.id!);

    // if (result.success && result.data.type === RQAPI.RecordType.API) {
    //   const httpApiEntry = result.data as RQAPI.HttpApiRecord;

    //   onSaveRecord({ ...(apiEntryDetails ?? {}), ...result.data, data: { ...result.data.data, ...record.data } });

    //   setEntry({ ...httpApiEntry.data, response: entry.response, testResults: entry.testResults });
    //   const { response, testResults, ...resultWithoutResponse } = result.data.data;
    //   resetChanges({ ...(resultWithoutResponse as RQAPI.HttpApiEntry), response: null });
    //   trackRequestSaved({
    //     src: "api_client_view",
    //     has_scripts: Boolean(entry.scripts?.preRequest),
    //     auth_type: entry?.auth?.currentAuthType,
    //     type: RQAPI.ApiEntryType.HTTP,
    //   });
    //   if (isCreateMode) {
    //     onSaveCallback(httpApiEntry);
    //   }
    //   toast.success("Request saved!");
    // } else {
    //   notification.error({
    //     message: `Could not save request.`,
    //     description: result?.message,
    //     placement: "bottomRight",
    //   });
    // }

    // setIsRequestSaving(false);
    endAISession();
  }, [
    onSaveCallback,
    // onSaveRecord,
    queryParams,
    endAISession,
  ]);

  const handleCancelRequest = useCallback(() => {
    httpRequestExecutor.abort();
    trackAPIRequestCancelled();
    setIsRequestCancelled(true);
  }, [httpRequestExecutor]);

  const handleAuthChange = useCallback(
    (newAuth: RQAPI.Auth) => {
      // const childDetails = {
      //   id: apiEntryDetails?.id,
      //   parentId: apiEntryDetails?.collectionId,
      // };

      // const resolvedAuth = resolveAuth(newAuth, childDetails, getParentChain, getData);
      // const { headers, queryParams } = parseAuth(resolvedAuth, resolver);
      // const headersContent = Object.fromEntries(headers);

      // const queryParamsContent: SimpleKeyValuePair[] = [];
      // queryParams.forEach(({ key, value }) => {
      //   queryParamsContent.push({ key, value });
      // });
      // purgeAndAdd(AutogeneratedFieldsNamespace.AUTH, headersContent, queryParamsContent);

      // setEntry((prevEntry) => {
      //   const updatedEntry = { ...prevEntry };
      //   updatedEntry.auth = newAuth;
      //   return updatedEntry;
      // });
      entity.setAuth(newAuth)
    },
    []
  );

  const onUrlInputEnterPressed = useCallback((evt: KeyboardEvent) => {
    (evt.target as HTMLInputElement).blur();
  }, []);

  const handleTestResultRefresh = useCallback(async () => {
    try {
      // const result = await httpRequestExecutor.rerun(apiEntryDetails?.id, entry);
      // if (result.status === RQAPI.ExecutionStatus.SUCCESS) {
      //   setEntry((entry) => ({
      //     ...entry,
      //     testResults: result.artifacts.testResults,
      //   }));
      // } else {
      //   setError(result.error);
      // }
    } catch (error) {
      toast.error("Something went wrong while refreshing test results");
    }
  }, [httpRequestExecutor]);

  const handleRevertChanges = () => {
    // setEntry(apiEntryDetails?.data);
  };


  const enableHotkey = getIsActive();

  return isExtensionEnabled ? (
    <div className="api-client-view http-client-view">
      <div className="api-client-header-container">
        <RoleBasedComponent
          permission="create"
          resource="api_client_request"
          fallback={
            <Conditional condition={user.loggedIn && !openInModal && hasUnsavedChanges}>
              <RevertViewModeChangesAlert
                title="As a viewer, You can modify and test APIs, but cannot save updates."
                callback={handleRevertChanges}
              />
            </Conditional>
          }
        />
        <div className="api-client-header-container__header">
          <div className="api-client-breadcrumb-container">
            <ApiClientBreadCrumb
              id={entity.meta.referenceId}
              openInModal={openInModal}
              placeholder="Untitled request"
              name={name}
              autoFocus={isNew}
              onBlur={(name) => {
                handleRecordNameUpdate(name);
              }}
              breadCrumbType={BreadcrumbType.API_REQUEST}
            />

            <ClientCodeButton
              requestPreparer={() => ({} as any)
                // httpRequestExecutor.requestPreparer.prepareRequest(apiEntryDetails?.id, entry).preparedEntry.request
              }
            />
          </div>

          <div className="api-client-header__url">
            <Space.Compact className="api-client-url-container">
              <Select
                popupClassName="api-request-method-selector"
                className="api-request-method-selector"
                options={requestMethodOptions}
                value={request.method}
                onChange={entity.setMethod.bind(entity)}
              />
              <HttpApiClientUrl
                entity={entity}
                url={request.url}
                onUrlChange={entity.setUrl.bind(entity)}
                onEnterPress={onUrlInputEnterPressed}
                currentEnvironmentVariables={scopedVariables}
              />
            </Space.Compact>
            <RQButton
              showHotKeyText
              onClick={onSendButtonClick}
              // hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SEND_REQUEST.hotKey}
              type="primary"
              className="text-bold"
              // enableHotKey={enableHotkey}
              disabled={
                !request.url ||
                (appMode === "EXTENSION" && request.contentType === RequestContentType.MULTIPART_FORM)
              }
            >
              Send
            </RQButton>

            <Conditional condition={!openInModal}>
              <RBACButton
                disabled={
                  !hasUnsavedChanges ||
                  (appMode === "EXTENSION" && request.contentType === RequestContentType.MULTIPART_FORM)
                }
                permission="create"
                resource="api_client_request"
                showHotKeyText
                hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SAVE_REQUEST.hotKey}
                onClick={onSaveButtonClick}
                loading={isRequestSaving}
                tooltipTitle="Saving is not allowed in view-only mode. You can update and view changes but cannot save them."
                enableHotKey={enableHotkey}
              >
                Save
              </RBACButton>
            </Conditional>
          </div>
        </div>
      </div>
      <BottomSheetLayout
        layout={SheetLayout.SPLIT}
        bottomSheet={
          <ApiClientBottomSheet
            response={response!}
            testResults={testResults ?? []}
            onGenerateTests={handleGenerateTests}
            isGeneratingTests={isGeneratingTests}
            canGenerateTests={canGenerateTests}
            isLoading={isLoadingResponse}
            isFailed={isFailed}
            isLongRequest={isLongRequest}
            isRequestCancelled={isRequestCancelled}
            onCancelRequest={handleCancelRequest}
            handleTestResultRefresh={handleTestResultRefresh}
            error={error}
            onDismissError={handleDismissError}
            warning={warning}
            executeRequest={onSendButtonClick}
          />
        }
        initialSizes={sheetPlacement === BottomSheetPlacement.BOTTOM ? [60, 40] : [50, 50]}
      >
        <div
          className={`api-client-body ${sheetPlacement === BottomSheetPlacement.BOTTOM ? "api-client-body__vertical" : "api-client-body__horizontal"
            }`}
        >
          <HttpRequestTabs
            error={error}
            entity={entity}
            handleAuthChange={handleAuthChange}
            focusPostResponseScriptEditor={focusPostResponseScriptEditor}
            scriptEditorVersion={scriptEditorVersion}
          />
        </div>
      </BottomSheetLayout>
    </div>
  ) : (
    <div className="w-full">
      <ExtensionDeactivationMessage />
    </div>
  );
};

const WithErrorBoundary = (Component: React.ComponentType<any>): React.FC<Props> => {
  const WrappedComponent: React.FC = (props: any) => {
    return (
      <ErrorBoundary boundaryId="http-client-view-error-boundary">
        <Component {...props} />
      </ErrorBoundary>
    );
  };

  return WrappedComponent;
};

export default React.memo(WithErrorBoundary(HttpClientView));
