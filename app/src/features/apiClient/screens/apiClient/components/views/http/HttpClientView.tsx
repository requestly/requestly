import React, { useCallback, useEffect, useLayoutEffect, useRef, useState, useContext } from "react";
import { notification, Select, Space } from "antd";
import { useDispatch } from "react-redux";
import * as Sentry from "@sentry/react";
import { KeyValuePair, RQAPI, RequestContentType, RequestMethod } from "../../../../../types";
import {
  checkForLargeFiles,
  getContentTypeFromResponseHeaders,
  getEmptyApiEntry,
  getEmptyPair,
  getRequestTypeForAnalyticEvent,
  parseHttpRequestEntry,
  resolveAuth,
  sanitizeEntry,
  supportsRequestBody,
} from "../../../utils";
import { isExtensionInstalled } from "actions/ExtensionActions";
import {
  trackAPIRequestCancelled,
  trackRequestFailed,
  trackResponseLoaded,
  trackInstallExtensionDialogShown,
  trackRequestSaved,
  trackRequestRenamed,
  trackApiRequestDone,
  trackAPIRequestSent,
} from "modules/analytics/events/features/apiClient";
import { useSelector } from "react-redux";
import { globalActions } from "store/slices/global/slice";
import { getAppMode, getIsExtensionEnabled } from "store/selectors";
import { getUserAuthDetails } from "store/slices/global/user/selectors";
import { CONTENT_TYPE_HEADER, INVALID_KEY_CHARACTERS } from "../../../../../constants";
import ExtensionDeactivationMessage from "components/misc/ExtensionDeactivationMessage";
import { trackRQDesktopLastActivity, trackRQLastActivity } from "utils/AnalyticsUtils";
import { API_CLIENT } from "modules/analytics/events/features/constants";
import { isDesktopMode } from "utils/AppUtils";
import { RQButton } from "lib/design-system-v2/components";
import { toast } from "utils/Toast";
import { BottomSheetLayout, useBottomSheetContext } from "componentsV2/BottomSheet";
import { BottomSheetPlacement, SheetLayout } from "componentsV2/BottomSheet/types";
import { ApiClientBottomSheet } from "../components/response/ApiClientBottomSheet/ApiClientBottomSheet";
import { KEYBOARD_SHORTCUTS } from "../../../../../../../constants/keyboardShortcuts";
import { useHasUnsavedChanges } from "hooks";
import { RBACButton, RevertViewModeChangesAlert, RoleBasedComponent } from "features/rbac";
import { Conditional } from "components/common/Conditional";
import { useGenericState } from "hooks/useGenericState";
import { useQueryParamStore } from "features/apiClient/hooks/useQueryParamStore";
import { AutogenerateStoreContext } from "features/apiClient/store/autogenerateContextProvider";
import { useAutogenerateStore } from "features/apiClient/hooks/useAutogenerateStore";
import {
  AutogeneratedFieldsNamespace,
  parseAuth,
  createHeaderEntry,
  SimpleKeyValuePair,
} from "features/apiClient/store/autogenerateStore";
import { useParentApiRecord } from "features/apiClient/hooks/useParentApiRecord.hook";
import { useScopedVariables } from "features/apiClient/helpers/variableResolver/variable-resolver";
import { useApiClientRepository } from "features/apiClient/contexts/meta";
import { renderVariables } from "backend/environment/utils";
import { useApiClientFeatureContext } from "features/apiClient/contexts/meta";
import HttpApiClientUrl from "./components/HttpClientUrl/HttpClientUrl";
import { ApiClientBreadCrumb, BreadcrumbType } from "../components/ApiClientBreadCrumb/ApiClientBreadCrumb";
import { ClientCodeButton } from "../components/ClientCodeButton/ClientCodeButton";
import HttpRequestTabs from "./components/HttpRequestTabs/HttpRequestTabs";
import "./httpClientView.scss";
import { QueryParamsProvider } from "features/apiClient/store/QueryParamsContextProvider";
import { MdOutlineSyncAlt } from "@react-icons/all-files/md/MdOutlineSyncAlt";
import { useLocation } from "react-router-dom";
import PATHS from "config/constants/sub/paths";
import { useAPIRecords, useAPIRecordsStore } from "features/apiClient/store/apiRecords/ApiRecordsContextProvider";
import { Authorization } from "../components/request/components/AuthorizationView/types/AuthConfig";
import { useNewApiClientContext } from "features/apiClient/hooks/useNewApiClientContext";
import ErrorBoundary from "features/apiClient/components/ErrorBoundary/ErrorBoundary";
import { useHttpRequestExecutor } from "features/apiClient/hooks/requestExecutors/useHttpRequestExecutor";
import { PathVariablesProvider } from "features/apiClient/store/pathVariables/PathVariablesContextProvider";
import { usePathVariablesStore } from "features/apiClient/hooks/usePathVariables.store";

const requestMethodOptions = Object.values(RequestMethod).map((method) => ({
  value: method,
  label: method,
}));

type BaseProps = {
  openInModal?: boolean;
  onSaveCallback?: (apiEntryDetails: RQAPI.HttpApiRecord) => void;
  notifyApiRequestFinished?: (apiEntry: RQAPI.HttpApiEntry) => void;
};

type CreateModeProps = BaseProps & {
  isCreateMode: true;
  apiEntryDetails:
    | null
    | ({
        data: RQAPI.HttpApiEntry; // If you want to prefill the details then only data can be passed in create mode
      } & Partial<RQAPI.HttpApiRecord>);
};

type EditModeProps = BaseProps & {
  isCreateMode: false;
  apiEntryDetails: RQAPI.HttpApiRecord;
};

type HistoryModeProps = BaseProps & {
  isCreateMode: false;
  apiEntryDetails: RQAPI.HttpApiRecord;
};

type Props = CreateModeProps | EditModeProps | HistoryModeProps;

const HttpClientView: React.FC<Props> = ({
  isCreateMode,
  openInModal = false,
  onSaveCallback,
  notifyApiRequestFinished,
  apiEntryDetails,
}) => {
  const dispatch = useDispatch();
  const location = useLocation();
  const appMode = useSelector(getAppMode);
  const isExtensionEnabled = useSelector(getIsExtensionEnabled);
  const user = useSelector(getUserAuthDetails);

  const { toggleBottomSheet, toggleSheetPlacement, sheetPlacement } = useBottomSheetContext();

  const { onSaveRecord } = useNewApiClientContext();

  const ctx = useApiClientFeatureContext();

  const { apiClientRecordsRepository } = useApiClientRepository();

  const scopedVariables = useScopedVariables(apiEntryDetails!.id!);

  const { version: parentVersion } = useParentApiRecord(apiEntryDetails?.id);
  const getPathVariables = usePathVariablesStore((state) => state.getPathVariables);

  const [requestName, setRequestName] = useState(apiEntryDetails?.name || "");
  const [entry, setEntry] = useState<RQAPI.HttpApiEntry>(
    apiEntryDetails?.data ?? (getEmptyApiEntry(RQAPI.ApiEntryType.HTTP) as RQAPI.HttpApiEntry)
  );

  const [isFailed, setIsFailed] = useState(false);
  const [error, setError] = useState<RQAPI.ExecutionError>(null);
  const [warning, setWarning] = useState<RQAPI.ExecutionWarning>(null);
  const [isRequestSaving, setIsRequestSaving] = useState(false);
  const [isLoadingResponse, setIsLoadingResponse] = useState(false);
  const [isLongRequest, setIsLongRequest] = useState(false);
  const [isRequestCancelled, setIsRequestCancelled] = useState(false);
  const autoGeneratedStore = useContext(AutogenerateStoreContext);

  const queryParams = useQueryParamStore((state) => state.queryParams);

  const { setPreview, setUnsaved, setTitle, getIsActive, setIcon } = useGenericState();

  const { response, testResults = undefined, ...entryWithoutResponse } = entry;

  const httpRequestExecutor = useHttpRequestExecutor(apiEntryDetails.collectionId);
  // Passing sanitized entry because response and empty key value pairs are saved in DB
  const { hasUnsavedChanges, resetChanges } = useHasUnsavedChanges(
    sanitizeEntry({ ...entryWithoutResponse, response: null }, false)
  );

  const isHistoryView = location.pathname.includes(PATHS.API_CLIENT.HISTORY.RELATIVE);

  const [purgeAndAdd, purgeAndAddHeaders] = useAutogenerateStore((state) => [
    state.purgeAndAdd,
    state.purgeAndAddHeaders,
  ]);
  const [getData, getParentChain] = useAPIRecords((state) => [state.getData, state.getParentChain]);

  const isDefaultPlacementRef = useRef(false);

  useLayoutEffect(() => {
    if (isDefaultPlacementRef.current) {
      return;
    }

    isDefaultPlacementRef.current = true;
    const bottomSheetPlacement = window.innerWidth < 1440 ? BottomSheetPlacement.BOTTOM : BottomSheetPlacement.RIGHT;
    toggleSheetPlacement(bottomSheetPlacement);
  }, [toggleSheetPlacement]);

  useEffect(() => {
    setEntry(apiEntryDetails?.data ?? (getEmptyApiEntry(RQAPI.ApiEntryType.HTTP) as RQAPI.HttpApiEntry));
  }, [apiEntryDetails?.data]);

  useLayoutEffect(() => {
    setUnsaved(hasUnsavedChanges);
  }, [setUnsaved, hasUnsavedChanges]);

  useEffect(() => {
    if (hasUnsavedChanges) {
      setPreview(false);
    }
  }, [setPreview, hasUnsavedChanges]);

  useEffect(() => {
    if (entry) {
      setRequestName("");
    }
  }, [entry]);

  const setMethod = useCallback((method: RequestMethod) => {
    setEntry((entry) => {
      const newEntry: RQAPI.HttpApiEntry = {
        ...entry,
        request: {
          ...entry.request,
          method,
        },
      };

      if (!supportsRequestBody(method)) {
        newEntry.request.body = null;
        newEntry.request.headers = newEntry.request.headers.filter((header) => header.key !== CONTENT_TYPE_HEADER);
        newEntry.request.contentType = RequestContentType.RAW;
      }
      return newEntry;
    });
  }, []);

  const setRequestEntry = useCallback((updater: (prev: RQAPI.HttpApiEntry) => RQAPI.HttpApiEntry) => {
    setEntry((prev) => updater(prev));
  }, []);

  const setContentType = useCallback(
    (contentType: RequestContentType) => {
      setEntry((entry) => {
        let newBody: RQAPI.RequestBody;

        if (contentType === RequestContentType.FORM || contentType === RequestContentType.MULTIPART_FORM) {
          newBody =
            entry.request.bodyContainer?.[contentType === RequestContentType.FORM ? "form" : "multipartForm"] ?? [];
        } else {
          newBody = entry.request.bodyContainer?.["text"] ?? "";
        }

        const newEntry: RQAPI.HttpApiEntry = {
          ...entry,
          request: {
            ...entry.request,
            body: newBody,
            contentType,
          },
        };

        const headers = newEntry.request.headers.filter((header) => header.key !== CONTENT_TYPE_HEADER);

        let contentTypeHeader = headers.find((header) => !header.key && !header.value); // reuse empty header
        if (!contentTypeHeader) {
          contentTypeHeader = getEmptyPair();
          headers.push(contentTypeHeader);
        }

        contentTypeHeader.key = CONTENT_TYPE_HEADER;
        contentTypeHeader.value = contentType;

        purgeAndAddHeaders(AutogeneratedFieldsNamespace.CONTENT_TYPE, {
          [contentTypeHeader.key]: createHeaderEntry(contentTypeHeader.key, contentTypeHeader.value),
        });
        return newEntry;
      });
    },
    [purgeAndAddHeaders]
  );

  const resolver = useCallback(
    <T extends Record<string, any>>(template: T) => {
      return renderVariables(template, apiEntryDetails.id, ctx).result;
    },
    [apiEntryDetails.id, ctx]
  );

  useEffect(() => {
    setIcon(<MdOutlineSyncAlt />);
  }, [setIcon]);

  useEffect(() => {
    if (isHistoryView) {
      setTitle("History");
    } else {
      setTitle(apiEntryDetails?.name || "Untitled request");
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [setTitle, isHistoryView]);

  useEffect(() => {
    //on mount run this
    if (!apiEntryDetails) {
      return;
    }
    const childDetails = {
      id: apiEntryDetails?.id,
      parentId: apiEntryDetails?.collectionId,
    };
    // resolving templates
    const resolvedEntry = resolver(entry);
    const namespaces = parseHttpRequestEntry(resolvedEntry, childDetails, getParentChain, getData);
    autoGeneratedStore.getState().initialize(namespaces);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (!apiEntryDetails) {
      return;
    }

    const childDetails = {
      id: apiEntryDetails?.id,
      parentId: apiEntryDetails?.collectionId,
    };
    const resolvedAuth = resolveAuth(apiEntryDetails?.data?.auth, childDetails, getParentChain, getData);
    const { headers, queryParams } = parseAuth(resolvedAuth, resolver);
    const headersContent = Object.fromEntries(headers);

    const queryParamsContent: SimpleKeyValuePair[] = [];
    queryParams.forEach(({ key, value }) => {
      queryParamsContent.push({ key, value });
    });
    purgeAndAdd(AutogeneratedFieldsNamespace.AUTH, headersContent, queryParamsContent);
  }, [apiEntryDetails, getData, getParentChain, purgeAndAdd, resolver, parentVersion]);

  const onSendButtonClick = useCallback(async () => {
    // updateTab(apiEntryDetails?.id, { isPreview: false });

    if (!entry.request.url) {
      return;
    }
    if (!isExtensionInstalled() && !isDesktopMode()) {
      /* SHOW INSTALL EXTENSION MODAL */
      const modalProps = {
        heading: "Install browser Extension to use the API Client",
        subHeading:
          "A minimalistic API Client for front-end developers to test their APIs and fast-track their web development lifecycle. Add custom Headers and Query Params to test your APIs.",
        eventPage: "api_client",
      };
      dispatch(globalActions.toggleActiveModal({ modalName: "extensionModal", newProps: modalProps }));
      trackInstallExtensionDialogShown({ src: "api_client" });
      return;
    }

    toggleBottomSheet({ isOpen: true, isTrack: false, action: "on_send_request_bottom_sheet" });

    setIsFailed(false);
    setError(null);
    setWarning(null);
    setIsLoadingResponse(true);
    setIsRequestCancelled(false);
    setIsLongRequest(false);

    const hasLargeFiles = checkForLargeFiles(entry.request.body);

    const longRequestTimer = setTimeout(() => {
      if (hasLargeFiles) {
        setIsLongRequest(true);
      }
    }, 5000);

    //Need to change the response and error to null
    setEntry((entry) => ({
      ...entry,
      error: null,
    }));

    const requestToSend = {
      ...entry,
      request: {
        ...entry.request,
        queryParams: queryParams,
        pathVariables: getPathVariables(),
      },
    };

    trackAPIRequestSent({
      has_scripts: Boolean(entry?.scripts?.preRequest),
      auth_type: entry?.auth?.currentAuthType,
      request_type: getRequestTypeForAnalyticEvent(apiEntryDetails?.isExample, entry?.request?.url),
      request_body_type: entry?.request?.contentType,
      type: RQAPI.ApiEntryType.HTTP,
    });

    try {
      const apiClientExecutionResult = await httpRequestExecutor.execute(
        apiEntryDetails?.id,
        sanitizeEntry(requestToSend)
      );

      const executedEntry = apiClientExecutionResult.executedEntry as RQAPI.HttpApiEntry;
      const entryWithResponse: RQAPI.HttpApiEntry = {
        ...entry,
        response: executedEntry.response,
        testResults: executedEntry.testResults,
      };
      setEntry(entryWithResponse);

      if (apiClientExecutionResult.status === "success") {
        if (apiClientExecutionResult.warning) {
          setWarning(apiClientExecutionResult.warning);
        }
        trackResponseLoaded({
          type: getContentTypeFromResponseHeaders(executedEntry.response.headers),
          time: Math.round(executedEntry.response.time / 1000),
        });
        trackApiRequestDone({
          url: executedEntry.request.url,
          method: executedEntry.request.method,
          status: executedEntry.response.status,
        });
        trackRQLastActivity(API_CLIENT.RESPONSE_LOADED);
        trackRQDesktopLastActivity(API_CLIENT.RESPONSE_LOADED);
      } else if (apiClientExecutionResult.status === "error") {
        const { error } = apiClientExecutionResult;
        setIsFailed(true);
        setError(error ?? null);
        if (error) {
          Sentry.withScope((scope) => {
            scope.setTag("error_type", "api_request_failure");
            scope.setContext("request_details", {
              url: entryWithResponse.request.url,
              method: entryWithResponse.request.method,
              headers: entryWithResponse.request.headers,
              queryParams: entryWithResponse.request.queryParams,
            });
            scope.setFingerprint(["api_request_error", entryWithResponse.request.method, error.source]);
            Sentry.captureException(new Error(`API Request Failed: ${error.message || "Unknown error"}`));
          });
        }
        trackRequestFailed(
          error.message,
          error.type,
          entryWithResponse.request.url,
          entryWithResponse.request.method,
          entryWithResponse.response?.status
        );
        trackRQLastActivity(API_CLIENT.REQUEST_FAILED);
        trackRQDesktopLastActivity(API_CLIENT.REQUEST_FAILED);
      }

      notifyApiRequestFinished?.(executedEntry);
    } catch (e) {
      setIsFailed(true);
      setError({
        type: e.type,
        source: "request",
        name: e.name,
        message: e.message,
      });
    } finally {
      clearTimeout(longRequestTimer);
      setIsLoadingResponse(false);
      setIsLongRequest(false);
    }
    trackRQLastActivity(API_CLIENT.REQUEST_SENT);
    trackRQDesktopLastActivity(API_CLIENT.REQUEST_SENT);
  }, [
    entry,
    toggleBottomSheet,
    queryParams,
    apiEntryDetails?.isExample,
    apiEntryDetails?.id,
    dispatch,
    httpRequestExecutor,
    notifyApiRequestFinished,
    getPathVariables,
  ]);

  const handleDismissError = () => {
    setError(null);
    setIsFailed(false);
    setIsLoadingResponse(false);
    setIsRequestCancelled(false);
  };

  const handleRecordNameUpdate = async () => {
    if (!requestName || requestName === apiEntryDetails?.name) {
      return;
    }

    const isValidHeader = entry.request?.headers?.every((header) => {
      return !header.isEnabled || !INVALID_KEY_CHARACTERS.test(header.key);
    });

    const isValidAuthKey =
      entry.auth?.currentAuthType !== Authorization.Type.API_KEY ||
      !entry.auth?.authConfigStore?.API_KEY?.key ||
      !INVALID_KEY_CHARACTERS.test(entry.auth?.authConfigStore?.API_KEY?.key);

    if (!isValidHeader || !isValidAuthKey) {
      notification.error({
        message: `Could not save request.`,
        description: "key contains invalid characters.",
        placement: "bottomRight",
      });
      return;
    }

    const record: Partial<RQAPI.HttpApiRecord> = {
      type: RQAPI.RecordType.API,
      data: { ...entry },
    };

    if (apiEntryDetails?.id) {
      record.id = apiEntryDetails?.id;
      record.name = requestName;
    }

    if (isCreateMode) {
      record.name = requestName;
    }

    const result = isCreateMode
      ? await apiClientRecordsRepository.createRecord(record)
      : await apiClientRecordsRepository.updateRecord(record, record.id);

    if (result.success && result.data.type === RQAPI.RecordType.API) {
      setTitle(requestName);
      const savedRecord: RQAPI.HttpApiRecord = {
        ...(apiEntryDetails ?? {}),
        ...result.data,
        data: { ...result.data.data, ...record.data },
      };
      onSaveRecord(savedRecord);
      trackRequestRenamed("breadcrumb");
      setRequestName("");
      onSaveCallback(savedRecord);

      toast.success("Request name updated!");
    } else {
      notification.error({
        message: `Could not rename Request.`,
        description: result?.message,
        placement: "bottomRight",
      });
    }
  };

  const onSaveButtonClick = useCallback(async () => {
    setIsRequestSaving(true);

    const entryToSave = {
      ...entry,
      request: {
        ...entry.request,
        url: entry.request.url.split("?")[0],
        queryParams: queryParams,
        pathVariables: getPathVariables(),
      },
    };
    const isValidHeader = entry.request?.headers?.every((header) => {
      return !header.isEnabled || !INVALID_KEY_CHARACTERS.test(header.key);
    });

    const isValidAuthKey =
      entry.auth?.currentAuthType !== Authorization.Type.API_KEY ||
      !entry.auth?.authConfigStore?.API_KEY?.key ||
      !INVALID_KEY_CHARACTERS.test(entry.auth?.authConfigStore?.API_KEY?.key) ||
      entry.auth?.authConfigStore?.API_KEY.addTo === "QUERY";

    if (!isValidHeader || !isValidAuthKey) {
      notification.error({
        message: `Could not save request.`,
        description: "key contains invalid characters.",
        placement: "bottomRight",
      });
      setIsRequestSaving(false);
      return;
    }

    const record: Partial<RQAPI.ApiRecord> = {
      type: RQAPI.RecordType.API,
      data: { ...sanitizeEntry(entryToSave, false) },
    };

    if (isCreateMode) {
      const requestId = apiClientRecordsRepository.generateApiRecordId();
      record.id = requestId;
    }

    //  Is this check necessary?
    if (apiEntryDetails?.id) {
      record.id = apiEntryDetails?.id;
    }

    const result = isCreateMode
      ? await apiClientRecordsRepository.createRecordWithId(record, record.id)
      : await apiClientRecordsRepository.updateRecord(record, record.id);

    if (result.success && result.data.type === RQAPI.RecordType.API) {
      const httpApiEntry = result.data as RQAPI.HttpApiRecord;

      onSaveRecord({ ...(apiEntryDetails ?? {}), ...result.data, data: { ...result.data.data, ...record.data } });

      setEntry({ ...httpApiEntry.data, response: entry.response, testResults: entry.testResults });
      const { response, testResults, ...resultWithoutResponse } = result.data.data;
      resetChanges({ ...(resultWithoutResponse as RQAPI.HttpApiEntry), response: null });
      trackRequestSaved({
        src: "api_client_view",
        has_scripts: Boolean(entry.scripts?.preRequest),
        auth_type: entry?.auth?.currentAuthType,
        type: RQAPI.ApiEntryType.HTTP,
      });
      if (isCreateMode) {
        onSaveCallback(httpApiEntry);
      }
      toast.success("Request saved!");
    } else {
      notification.error({
        message: `Could not save request.`,
        description: result?.message,
        placement: "bottomRight",
      });
    }

    setIsRequestSaving(false);
  }, [
    apiClientRecordsRepository,
    apiEntryDetails,
    entry,
    isCreateMode,
    onSaveCallback,
    onSaveRecord,
    resetChanges,
    queryParams,
    getPathVariables,
  ]);

  const handleCancelRequest = useCallback(() => {
    httpRequestExecutor.abort();
    trackAPIRequestCancelled();
    setIsRequestCancelled(true);
  }, [httpRequestExecutor]);

  const handleAuthChange = useCallback(
    (newAuth: RQAPI.Auth) => {
      const childDetails = {
        id: apiEntryDetails?.id,
        parentId: apiEntryDetails?.collectionId,
      };

      const resolvedAuth = resolveAuth(newAuth, childDetails, getParentChain, getData);
      const { headers, queryParams } = parseAuth(resolvedAuth, resolver);
      const headersContent = Object.fromEntries(headers);

      const queryParamsContent: SimpleKeyValuePair[] = [];
      queryParams.forEach(({ key, value }) => {
        queryParamsContent.push({ key, value });
      });
      purgeAndAdd(AutogeneratedFieldsNamespace.AUTH, headersContent, queryParamsContent);

      setEntry((prevEntry) => {
        const updatedEntry = { ...prevEntry };
        updatedEntry.auth = newAuth;
        return updatedEntry;
      });
    },
    [apiEntryDetails?.collectionId, apiEntryDetails?.id, getData, getParentChain, purgeAndAdd, resolver]
  );

  const onUrlInputEnterPressed = useCallback((evt: KeyboardEvent) => {
    (evt.target as HTMLInputElement).blur();
  }, []);

  const handleTestResultRefresh = useCallback(async () => {
    try {
      const result = await httpRequestExecutor.rerun(apiEntryDetails?.id, entry);
      if (result.status === RQAPI.ExecutionStatus.SUCCESS) {
        setEntry((entry) => ({
          ...entry,
          testResults: result.artifacts.testResults,
        }));
      } else {
        setError(result.error);
      }
    } catch (error) {
      toast.error("Something went wrong while refreshing test results");
    }
  }, [httpRequestExecutor, apiEntryDetails?.id, entry]);

  const handleRevertChanges = () => {
    setEntry(apiEntryDetails?.data);
  };

  const handleOnUrlChange = (value: string, params: KeyValuePair[]) => {
    setEntry((prevEntry) => ({
      ...prevEntry,
      request: { ...prevEntry.request, url: value, queryParams: params },
    }));
    setUnsaved(true);
  };

  const enableHotkey = getIsActive();

  return isExtensionEnabled ? (
    <div className="api-client-view http-client-view">
      <div className="api-client-header-container">
        <RoleBasedComponent
          permission="create"
          resource="api_client_request"
          fallback={
            <Conditional condition={user.loggedIn && !openInModal && hasUnsavedChanges}>
              <RevertViewModeChangesAlert
                title="As a viewer, You can modify and test APIs, but cannot save updates."
                callback={handleRevertChanges}
              />
            </Conditional>
          }
        />
        <div className="api-client-header-container__header">
          <div className="api-client-breadcrumb-container">
            <ApiClientBreadCrumb
              id={apiEntryDetails.id}
              openInModal={openInModal}
              placeholder="Untitled request"
              name={apiEntryDetails?.name}
              onRecordNameUpdate={setRequestName}
              onBlur={handleRecordNameUpdate}
              breadCrumbType={BreadcrumbType.API_REQUEST}
            />

            <ClientCodeButton
              requestPreparer={() =>
                httpRequestExecutor.requestPreparer.prepareRequest(apiEntryDetails?.id, entry).preparedEntry.request
              }
            />
          </div>

          <div className="api-client-header__url">
            <Space.Compact className="api-client-url-container">
              <Select
                popupClassName="api-request-method-selector"
                className="api-request-method-selector"
                options={requestMethodOptions}
                value={entry.request.method}
                onChange={setMethod}
              />
              <HttpApiClientUrl
                url={entry.request.url}
                onUrlChange={handleOnUrlChange}
                onEnterPress={onUrlInputEnterPressed}
                currentEnvironmentVariables={scopedVariables}
              />
            </Space.Compact>
            <RQButton
              showHotKeyText
              onClick={onSendButtonClick}
              hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SEND_REQUEST.hotKey}
              type="primary"
              className="text-bold"
              disabled={
                !entry.request.url ||
                (appMode === "EXTENSION" && entry.request.contentType === RequestContentType.MULTIPART_FORM)
              }
            >
              Send
            </RQButton>

            <Conditional condition={!openInModal}>
              <RBACButton
                disabled={
                  !hasUnsavedChanges ||
                  (appMode === "EXTENSION" && entry.request.contentType === RequestContentType.MULTIPART_FORM)
                }
                permission="create"
                resource="api_client_request"
                showHotKeyText
                hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SAVE_REQUEST.hotKey}
                onClick={onSaveButtonClick}
                loading={isRequestSaving}
                tooltipTitle="Saving is not allowed in view-only mode. You can update and view changes but cannot save them."
                enableHotKey={enableHotkey}
              >
                Save
              </RBACButton>
            </Conditional>
          </div>
        </div>
      </div>
      <BottomSheetLayout
        layout={SheetLayout.SPLIT}
        bottomSheet={
          <ApiClientBottomSheet
            key={apiEntryDetails?.id}
            response={entry.response}
            testResults={testResults}
            isLoading={isLoadingResponse}
            isFailed={isFailed}
            isLongRequest={isLongRequest}
            isRequestCancelled={isRequestCancelled}
            onCancelRequest={handleCancelRequest}
            handleTestResultRefresh={handleTestResultRefresh}
            error={error}
            onDismissError={handleDismissError}
            warning={warning}
            executeRequest={onSendButtonClick}
          />
        }
        minSize={sheetPlacement === BottomSheetPlacement.BOTTOM ? 25 : 350}
        initialSizes={sheetPlacement === BottomSheetPlacement.BOTTOM ? [60, 40] : [50, 50]}
      >
        <div className="api-client-body">
          <HttpRequestTabs
            requestEntry={entry}
            requestId={apiEntryDetails?.id}
            collectionId={apiEntryDetails?.collectionId}
            setRequestEntry={setRequestEntry}
            setContentType={setContentType}
            handleAuthChange={handleAuthChange}
          />
        </div>
      </BottomSheetLayout>
    </div>
  ) : (
    <div className="w-full">
      <ExtensionDeactivationMessage />
    </div>
  );
};

const WithQueryParamsProvider = (Component: React.ComponentType<any>): React.FC => {
  const WrappedComponent: React.FC = (props: any) => {
    const record = useAPIRecordsStore().getState().getData(props.apiEntryDetails.id) as RQAPI.ApiClientRecord;
    const entry = (record?.data as RQAPI.HttpApiEntry) || props.apiEntryDetails.data;

    return (
      <ErrorBoundary>
        <PathVariablesProvider pathVariables={entry.request?.pathVariables}>
          <QueryParamsProvider entry={entry}>
            <Component {...props} />
          </QueryParamsProvider>
        </PathVariablesProvider>
      </ErrorBoundary>
    );
  };

  return WrappedComponent;
};

export default React.memo(WithQueryParamsProvider(HttpClientView));
