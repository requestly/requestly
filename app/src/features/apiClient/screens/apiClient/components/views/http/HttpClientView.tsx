import React, { useCallback, useEffect, useLayoutEffect, useState, useMemo } from "react";
import { notification, Select, Space } from "antd";
import { useDispatch } from "react-redux";
import * as Sentry from "@sentry/react";
import { KeyValuePair, RQAPI, RequestContentType, RequestMethod } from "../../../../../types";
import {
  hasTests,
  buildAutogeneratedTestsBlock,
  injectAutogeneratedTests,
} from "features/apiClient/helpers/testGeneration/buildPostResponseTests";
import {
  checkForLargeFiles,
  getContentTypeFromResponseHeaders,
  getEmptyApiEntry,
  getRequestTypeForAnalyticEvent,
  parseHttpRequestEntry,
  resolveAuth,
  sanitizeEntry,
  supportsRequestBody,
} from "../../../utils";
import { isExtensionInstalled } from "actions/ExtensionActions";
import {
  trackAPIRequestCancelled,
  trackRequestFailed,
  trackResponseLoaded,
  trackInstallExtensionDialogShown,
  trackRequestSaved,
  trackRequestRenamed,
  trackApiRequestDone,
  trackAPIRequestSent,
  trackTestGenerationStarted,
  trackTestGenerationCompleted,
  trackTestGenerationFailed,
} from "modules/analytics/events/features/apiClient";
import { useSelector } from "react-redux";
import { globalActions } from "store/slices/global/slice";
import { getAppMode, getIsExtensionEnabled } from "store/selectors";
import { getUserAuthDetails } from "store/slices/global/user/selectors";
import { CONTENT_TYPE_HEADER, INVALID_KEY_CHARACTERS } from "../../../../../constants";
import ExtensionDeactivationMessage from "components/misc/ExtensionDeactivationMessage";
import { trackRQDesktopLastActivity, trackRQLastActivity } from "utils/AnalyticsUtils";
import { API_CLIENT } from "modules/analytics/events/features/constants";
import { isDesktopMode } from "utils/AppUtils";
import { RQButton } from "lib/design-system-v2/components";
import { toast } from "utils/Toast";
import { BottomSheetLayout, useBottomSheetContext } from "componentsV2/BottomSheet";
import { BottomSheetPlacement, SheetLayout } from "componentsV2/BottomSheet/types";
import { ApiClientBottomSheet } from "../components/response/ApiClientBottomSheet/ApiClientBottomSheet";
import { KEYBOARD_SHORTCUTS } from "../../../../../../../constants/keyboardShortcuts";
import { useDeepLinkState, useHasUnsavedChanges } from "hooks";
import { RBACButton, RevertViewModeChangesAlert, RoleBasedComponent } from "features/rbac";
import { Conditional } from "components/common/Conditional";
import { useGenericState } from "hooks/useGenericState";
import { useQueryParamStore } from "features/apiClient/hooks/useQueryParamStore";
import { useAutogenerateStoreContext } from "features/apiClient/store/autogenerateContextProvider";
import { useAutogenerateStore } from "features/apiClient/hooks/useAutogenerateStore";
import {
  AutogeneratedFieldsNamespace,
  parseAuth,
  SimpleKeyValuePair,
} from "features/apiClient/store/autogenerateStore";
import { useParentApiRecord } from "features/apiClient/hooks/useParentApiRecord.hook";
import { useScopedVariables } from "features/apiClient/helpers/variableResolver/variable-resolver";
import { useApiClientRepository } from "features/apiClient/contexts/meta";
import { renderVariables } from "backend/environment/utils";
import { useApiClientFeatureContext } from "features/apiClient/contexts/meta";
import HttpApiClientUrl from "./components/HttpClientUrl/HttpClientUrl";
import { ApiClientBreadCrumb, BreadcrumbType } from "../components/ApiClientBreadCrumb/ApiClientBreadCrumb";
import { ClientCodeButton } from "../components/ClientCodeButton/ClientCodeButton";
import HttpRequestTabs, { RequestTab } from "./components/HttpRequestTabs/HttpRequestTabs";
import "./httpClientView.scss";
import { QueryParamsProvider } from "features/apiClient/store/QueryParamsContextProvider";
import { MdOutlineSyncAlt } from "@react-icons/all-files/md/MdOutlineSyncAlt";
import { useLocation } from "react-router-dom";
import PATHS from "config/constants/sub/paths";
import { useAPIRecords, useAPIRecordsStore } from "features/apiClient/store/apiRecords/ApiRecordsContextProvider";
import { Authorization } from "../components/request/components/AuthorizationView/types/AuthConfig";
import { useNewApiClientContext } from "features/apiClient/hooks/useNewApiClientContext";
import { apiRecordsRankingManager } from "features/apiClient/helpers/RankingManager";
import ErrorBoundary from "features/apiClient/components/ErrorBoundary/ErrorBoundary";
import { useHttpRequestExecutor } from "features/apiClient/hooks/requestExecutors/useHttpRequestExecutor";
import { PathVariablesProvider } from "features/apiClient/store/pathVariables/PathVariablesContextProvider";
import { usePathVariablesStore } from "features/apiClient/hooks/usePathVariables.store";
import { useAISessionContext } from "features/ai/contexts/AISession";

const requestMethodOptions = Object.values(RequestMethod).map((method) => ({
  value: method,
  label: method,
}));

type Props = {
  isCreateMode: boolean;
  apiEntryDetails: RQAPI.HttpApiRecord;
  openInModal?: boolean;
  onSaveCallback: (apiEntryDetails: RQAPI.HttpApiRecord) => void;
  notifyApiRequestFinished: (apiEntry: RQAPI.HttpApiEntry) => void;
};

const HttpClientView: React.FC<Props> = ({
  isCreateMode,
  openInModal = false,
  onSaveCallback,
  notifyApiRequestFinished,
  apiEntryDetails,
}) => {
  const dispatch = useDispatch();
  const location = useLocation();
  const appMode = useSelector(getAppMode);
  const isExtensionEnabled = useSelector(getIsExtensionEnabled);
  const user = useSelector(getUserAuthDetails);

  const [, setDeepLinkState] = useDeepLinkState({ tab: RequestTab.QUERY_PARAMS });

  const { toggleBottomSheet, sheetPlacement } = useBottomSheetContext();

  const { onSaveRecord } = useNewApiClientContext();

  const ctx = useApiClientFeatureContext();

  const { apiClientRecordsRepository } = useApiClientRepository();

  const { endAISession } = useAISessionContext();
  const scopedVariables = useScopedVariables(apiEntryDetails!.id!);

  const { version: parentVersion } = useParentApiRecord(apiEntryDetails?.id);
  const getPathVariables = usePathVariablesStore((state) => state.getPathVariables);

  const [requestName, setRequestName] = useState(apiEntryDetails?.name || "");
  const [entry, setEntry] = useState<RQAPI.HttpApiEntry>(
    apiEntryDetails?.data ?? (getEmptyApiEntry(RQAPI.ApiEntryType.HTTP) as RQAPI.HttpApiEntry)
  );

  const [isFailed, setIsFailed] = useState(false);
  const [isGeneratingTests, setIsGeneratingTests] = useState(false);
  const [scriptEditorVersion, setScriptEditorVersion] = useState(0);

  const [focusPostResponseScriptEditor, setFocusPostResponseScriptEditor] = useState(false);
  const [error, setError] = useState<RQAPI.ExecutionError | null>(null);
  const [warning, setWarning] = useState<RQAPI.ExecutionWarning | null>(null);
  const [isRequestSaving, setIsRequestSaving] = useState(false);
  const [isLoadingResponse, setIsLoadingResponse] = useState(false);
  const [isLongRequest, setIsLongRequest] = useState(false);
  const [isRequestCancelled, setIsRequestCancelled] = useState(false);
  const autoGeneratedStore = useAutogenerateStoreContext();

  const queryParams = useQueryParamStore((state) => state.queryParams);

  const { setPreview, setUnsaved, setTitle, getIsActive, setIcon, getIsNew, setIsNew } = useGenericState();

  const { response, testResults = undefined, ...entryWithoutResponse } = entry;

  const httpRequestExecutor = useHttpRequestExecutor(apiEntryDetails.collectionId);

  const handleGenerateTests = useCallback(async () => {
    if (!entry?.response || isGeneratingTests) {
      return;
    }

    setIsGeneratingTests(true);
    trackTestGenerationStarted({
      src: "test_tab_response_panel",
    });
    const method = entry.request.method;
    const status = entry.response.status;

    let hasJsonObjectBody = false;
    try {
      const contentType = getContentTypeFromResponseHeaders(entry.response.headers) ?? "";
      const isJson = /application\/json/i.test(contentType);
      if (isJson) {
        const parsed = JSON.parse(entry.response.body || "null");
        hasJsonObjectBody = parsed && typeof parsed === "object" && !Array.isArray(parsed);
      }
    } catch (_) {
      hasJsonObjectBody = false;
    }

    try {
      const existingScript = entry.scripts?.postResponse || "";
      if (hasTests(existingScript)) {
        setIsGeneratingTests(false);
        return;
      }
      const block = buildAutogeneratedTestsBlock({
        method,
        status,
        hasJsonObjectBody,
      });

      setFocusPostResponseScriptEditor(true);
      const newScript = injectAutogeneratedTests(existingScript, block);

      setEntry((prev) => ({
        ...prev,
        scripts: {
          preRequest: prev.scripts?.preRequest || "",
          postResponse: newScript,
        },
      }));

      setScriptEditorVersion((prev) => prev + 1);
      setDeepLinkState({ tab: RequestTab.SCRIPTS });
      trackTestGenerationCompleted({
        src: "test_tab_response_panel",
      });
    } catch (e) {
      toast.error("Something went wrong while generating tests");
      trackTestGenerationFailed({
        src: "test_tab_response_panel",
      });
    } finally {
      setIsGeneratingTests(false);
    }
  }, [entry.request.method, entry.response, entry.scripts?.postResponse, isGeneratingTests, setDeepLinkState]);

  const canGenerateTests = useMemo(() => {
    const responseExists = Boolean(entry?.response);
    if (!responseExists) return false;
    const postResponseScript = entry.scripts?.postResponse || "";
    return !hasTests(postResponseScript);
  }, [entry?.response, entry.scripts?.postResponse]);

  // Passing sanitized entry because response and empty key value pairs are saved in DB
  const { hasUnsavedChanges, resetChanges } = useHasUnsavedChanges(
    sanitizeEntry({ ...entryWithoutResponse, response: null }, false)
  );

  const isHistoryView = location.pathname.includes(PATHS.API_CLIENT.HISTORY.RELATIVE);

  const [purgeAndAdd] = useAutogenerateStore((state) => [state.purgeAndAdd, state.purgeAndAddHeaders]);
  const [getData, getParentChain] = useAPIRecords((state) => [state.getData, state.getParentChain]);

  useEffect(() => {
    setEntry(apiEntryDetails?.data ?? (getEmptyApiEntry(RQAPI.ApiEntryType.HTTP) as RQAPI.HttpApiEntry));
  }, [apiEntryDetails?.data]);

  useLayoutEffect(() => {
    setUnsaved(hasUnsavedChanges);
  }, [setUnsaved, hasUnsavedChanges]);

  useEffect(() => {
    if (hasUnsavedChanges) {
      setPreview(false);
    }
  }, [setPreview, hasUnsavedChanges]);

  useEffect(() => {
    if (entry) {
      setRequestName("");
    }
  }, [entry]);

  const setMethod = useCallback((method: RequestMethod) => {
    setEntry((entry) => {
      const newEntry: RQAPI.HttpApiEntry = {
        ...entry,
        request: {
          ...entry.request,
          method,
        },
      };

      if (!supportsRequestBody(method)) {
        delete newEntry.request.body;
        newEntry.request.headers = newEntry.request.headers.filter((header) => header.key !== CONTENT_TYPE_HEADER);
        newEntry.request.contentType = RequestContentType.RAW;
      }
      return newEntry;
    });
  }, []);

  const setRequestEntry = useCallback((updater: (prev: RQAPI.HttpApiEntry) => RQAPI.HttpApiEntry) => {
    setEntry((prev) => updater(prev));
  }, []);

  const resolver = useCallback(
    <T extends Record<string, any>>(template: T) => {
      return renderVariables(template, apiEntryDetails.id, ctx).result;
    },
    [apiEntryDetails.id, ctx]
  );

  useEffect(() => {
    setIcon(<MdOutlineSyncAlt />);
  }, [setIcon]);

  useEffect(() => {
    if (isHistoryView) {
      setTitle("History");
    } else {
      setTitle(apiEntryDetails?.name || "Untitled request");
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [setTitle, isHistoryView]);

  useEffect(() => {
    //on mount run this
    if (!apiEntryDetails) {
      return;
    }
    const childDetails = {
      id: apiEntryDetails?.id,
      parentId: apiEntryDetails?.collectionId,
    };
    const namespaces = parseHttpRequestEntry(entry, childDetails, {
      getParentChain,
      getData,
      resolver,
    });
    autoGeneratedStore.getState().initialize(namespaces);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (!apiEntryDetails) {
      return;
    }

    const childDetails = {
      id: apiEntryDetails.id,
      parentId: apiEntryDetails.collectionId,
    };
    const resolvedAuth = resolveAuth(apiEntryDetails?.data?.auth, childDetails, getParentChain, getData);
    const { headers, queryParams } = parseAuth(resolvedAuth, resolver);
    const headersContent = Object.fromEntries(headers);

    const queryParamsContent: SimpleKeyValuePair[] = [];
    queryParams.forEach(({ key, value }) => {
      queryParamsContent.push({ key, value });
    });
    purgeAndAdd(AutogeneratedFieldsNamespace.AUTH, headersContent, queryParamsContent);
  }, [apiEntryDetails, getData, getParentChain, purgeAndAdd, resolver, parentVersion]);

  const onSendButtonClick = useCallback(async () => {
    // updateTab(apiEntryDetails?.id, { isPreview: false });

    if (!entry.request.url) {
      return;
    }
    if (!isExtensionInstalled() && !isDesktopMode()) {
      /* SHOW INSTALL EXTENSION MODAL */
      const modalProps = {
        heading: "Install browser Extension to use the API Client",
        subHeading:
          "A minimalistic API Client for front-end developers to test their APIs and fast-track their web development lifecycle. Add custom Headers and Query Params to test your APIs.",
        eventPage: "api_client",
      };
      dispatch(globalActions.toggleActiveModal({ modalName: "extensionModal", newProps: modalProps }));
      trackInstallExtensionDialogShown({ src: "api_client" });
      return;
    }

    toggleBottomSheet({ isOpen: true, action: "on_send_request_bottom_sheet" });

    setIsFailed(false);
    setError(null);
    setWarning(null);
    setIsLoadingResponse(true);
    setIsRequestCancelled(false);
    setIsLongRequest(false);

    const hasLargeFiles = entry.request.body ? checkForLargeFiles(entry.request.body) : false;

    const longRequestTimer = setTimeout(() => {
      if (hasLargeFiles) {
        setIsLongRequest(true);
      }
    }, 5000);

    //Need to change the response and error to null
    setEntry((entry) => ({
      ...entry,
      error: null,
    }));

    const requestToSend = {
      ...entry,
      request: {
        ...entry.request,
        queryParams: queryParams,
        pathVariables: getPathVariables(),
      },
    };

    trackAPIRequestSent({
      has_scripts: Boolean(entry?.scripts?.preRequest),
      auth_type: entry?.auth?.currentAuthType,
      request_type: getRequestTypeForAnalyticEvent(apiEntryDetails?.isExample, entry?.request?.url),
      request_body_type: entry?.request?.contentType,
      type: RQAPI.ApiEntryType.HTTP,
    });

    try {
      const apiClientExecutionResult = await httpRequestExecutor.execute(
        {
          entry: sanitizeEntry(requestToSend),
          recordId: apiEntryDetails?.id,
        },
        {
          iteration: 0,
          iterationCount: 1,
        }
      );

      const executedEntry = apiClientExecutionResult.executedEntry as RQAPI.HttpApiEntry;
      const entryWithResponse: RQAPI.HttpApiEntry = {
        ...entry,
        response: executedEntry.response,
        testResults: executedEntry.testResults,
      };
      setEntry(entryWithResponse);

      if (apiClientExecutionResult.status === "success" && executedEntry.response) {
        if (apiClientExecutionResult.warning) {
          setWarning(apiClientExecutionResult.warning);
        }
        trackResponseLoaded({
          type: getContentTypeFromResponseHeaders(executedEntry.response.headers),
          time: Math.round(executedEntry.response?.time / 1000),
        });
        trackApiRequestDone({
          url: executedEntry.request.url,
          method: executedEntry.request.method,
          status: executedEntry.response.status,
        });
        trackRQLastActivity(API_CLIENT.RESPONSE_LOADED);
        trackRQDesktopLastActivity(API_CLIENT.RESPONSE_LOADED);
      } else if (apiClientExecutionResult.status === "error") {
        const { error } = apiClientExecutionResult;
        setIsFailed(true);
        setError(error ?? null);
        if (error) {
          Sentry.withScope((scope) => {
            scope.setTag("error_type", "api_request_failure");
            scope.setContext("request_details", {
              url: entryWithResponse.request.url,
              method: entryWithResponse.request.method,
              headers: entryWithResponse.request.headers,
              queryParams: entryWithResponse.request.queryParams,
            });
            scope.setFingerprint(["api_request_error", entryWithResponse.request.method, error.source]);
            Sentry.captureException(new Error(`API Request Failed: ${error.message || "Unknown error"}`));
          });
        }
        trackRequestFailed(
          error.message,
          error.type,
          entryWithResponse.request.url,
          entryWithResponse.request.method,
          entryWithResponse.response?.status
        );
        trackRQLastActivity(API_CLIENT.REQUEST_FAILED);
        trackRQDesktopLastActivity(API_CLIENT.REQUEST_FAILED);
      }

      notifyApiRequestFinished(executedEntry);
    } catch (e) {
      setIsFailed(true);
      setError({
        type: e.type,
        source: "request",
        name: e.name,
        message: e.message,
      });
    } finally {
      clearTimeout(longRequestTimer);
      setIsLoadingResponse(false);
      setIsLongRequest(false);
      endAISession();
    }
    trackRQLastActivity(API_CLIENT.REQUEST_SENT);
    trackRQDesktopLastActivity(API_CLIENT.REQUEST_SENT);
  }, [
    entry,
    toggleBottomSheet,
    queryParams,
    apiEntryDetails?.isExample,
    apiEntryDetails?.id,
    dispatch,
    httpRequestExecutor,
    notifyApiRequestFinished,
    getPathVariables,
    endAISession,
  ]);

  const handleDismissError = () => {
    setError(null);
    setIsFailed(false);
    setIsLoadingResponse(false);
    setIsRequestCancelled(false);
  };

  const handleRecordNameUpdate = async () => {
    if (!requestName || requestName === apiEntryDetails?.name) {
      return;
    }

    const isValidHeader = entry.request?.headers?.every((header) => {
      return !header.isEnabled || !INVALID_KEY_CHARACTERS.test(header.key);
    });

    const isValidAuthKey =
      entry.auth?.currentAuthType !== Authorization.Type.API_KEY ||
      !entry.auth?.authConfigStore?.API_KEY?.key ||
      !INVALID_KEY_CHARACTERS.test(entry.auth?.authConfigStore?.API_KEY?.key);

    if (!isValidHeader || !isValidAuthKey) {
      notification.error({
        message: `Could not save request.`,
        description: "key contains invalid characters.",
        placement: "bottomRight",
      });
      return;
    }

    const record: Partial<RQAPI.ApiRecord> = {
      type: RQAPI.RecordType.API,
      data: { ...entry },
    };

    if (apiEntryDetails?.id) {
      record.id = apiEntryDetails?.id;
      record.name = requestName;
    }

    if (isCreateMode) {
      record.name = requestName;
    }

    // If record does not have a rank generate one using old data to mantain order in UI
    if (!isCreateMode && !apiEntryDetails.rank) {
      const effectiveRank = apiRecordsRankingManager.getEffectiveRank(apiEntryDetails);
      record.rank = effectiveRank;
    }

    if (isCreateMode && !apiEntryDetails.rank) {
      const newRank = apiRecordsRankingManager.getRanksForNewApis(ctx, apiEntryDetails?.collectionId || "", [
        record as RQAPI.ApiClientRecord,
      ])[0];
      record.rank = newRank;
    }

    const result = isCreateMode
      ? await apiClientRecordsRepository.createRecord(record)
      : await apiClientRecordsRepository.updateRecord(record, record.id!); // not the ideal way but had to assert because record is typed as Partial here

    if (result.success && result.data.type === RQAPI.RecordType.API) {
      setTitle(requestName);
      const savedRecord: RQAPI.HttpApiRecord = {
        ...(apiEntryDetails ?? {}),
        ...result.data,
        data: { ...result.data.data, ...record.data } as RQAPI.HttpApiEntry,
      };
      onSaveRecord(savedRecord);
      trackRequestRenamed("breadcrumb");
      setRequestName("");
      onSaveCallback(savedRecord);

      toast.success("Request name updated!");
    } else {
      notification.error({
        message: `Could not rename Request.`,
        description: result?.message,
        placement: "bottomRight",
      });
    }
  };

  const onSaveButtonClick = useCallback(async () => {
    setIsRequestSaving(true);

    const entryToSave = {
      ...entry,
      request: {
        ...entry.request,
        url: entry.request.url.split("?")[0],
        queryParams: queryParams,
        pathVariables: getPathVariables(),
      },
    };
    const isValidHeader = entry.request?.headers?.every((header) => {
      return !header.isEnabled || !INVALID_KEY_CHARACTERS.test(header.key);
    });

    const isValidAuthKey =
      entry.auth?.currentAuthType !== Authorization.Type.API_KEY ||
      !entry.auth?.authConfigStore?.API_KEY?.key ||
      !INVALID_KEY_CHARACTERS.test(entry.auth?.authConfigStore?.API_KEY?.key) ||
      entry.auth?.authConfigStore?.API_KEY.addTo === "QUERY";

    if (!isValidHeader || !isValidAuthKey) {
      notification.error({
        message: `Could not save request.`,
        description: "key contains invalid characters.",
        placement: "bottomRight",
      });
      setIsRequestSaving(false);
      return;
    }

    const record: Partial<RQAPI.ApiRecord> = {
      type: RQAPI.RecordType.API,
      data: { ...sanitizeEntry(entryToSave, false) },
    };

    if (isCreateMode) {
      const requestId = apiClientRecordsRepository.generateApiRecordId();
      record.id = requestId;
      const collectionId = apiEntryDetails?.collectionId || "";
      record.rank = apiRecordsRankingManager.getRanksForNewApis(ctx, collectionId, [record])[0];
    }

    //  Is this check necessary?
    if (apiEntryDetails?.id) {
      record.id = apiEntryDetails?.id;

      // If record does not have a rank generate one using old data to mantain order in UI
      if (!apiEntryDetails.rank) {
        const effectiveRank = apiRecordsRankingManager.getEffectiveRank(apiEntryDetails);
        record.rank = effectiveRank;
      }
    }

    const result = isCreateMode
      ? await apiClientRecordsRepository.createRecordWithId(record, record.id!) // not the ideal way but had to assert because record is typed as Partial here
      : await apiClientRecordsRepository.updateRecord(record, record.id!);

    if (result.success && result.data.type === RQAPI.RecordType.API) {
      const httpApiEntry = result.data as RQAPI.HttpApiRecord;

      onSaveRecord({ ...(apiEntryDetails ?? {}), ...result.data, data: { ...result.data.data, ...record.data } });

      setEntry({ ...httpApiEntry.data, response: entry.response, testResults: entry.testResults });
      const { response, testResults, ...resultWithoutResponse } = result.data.data;
      resetChanges({ ...(resultWithoutResponse as RQAPI.HttpApiEntry), response: null });
      trackRequestSaved({
        src: "api_client_view",
        has_scripts: Boolean(entry.scripts?.preRequest),
        auth_type: entry?.auth?.currentAuthType,
        type: RQAPI.ApiEntryType.HTTP,
      });
      if (isCreateMode) {
        onSaveCallback(httpApiEntry);
      }
      toast.success("Request saved!");
    } else {
      notification.error({
        message: `Could not save request.`,
        description: result?.message,
        placement: "bottomRight",
      });
    }

    setIsRequestSaving(false);
    endAISession();
  }, [
    entry,
    queryParams,
    getPathVariables,
    isCreateMode,
    apiEntryDetails,
    apiClientRecordsRepository,
    endAISession,
    ctx,
    onSaveRecord,
    resetChanges,
    onSaveCallback,
  ]);

  const handleCancelRequest = useCallback(() => {
    httpRequestExecutor.abort();
    trackAPIRequestCancelled();
    setIsRequestCancelled(true);
  }, [httpRequestExecutor]);

  const handleAuthChange = useCallback(
    (newAuth: RQAPI.Auth) => {
      const childDetails = {
        id: apiEntryDetails?.id,
        parentId: apiEntryDetails?.collectionId,
      };

      const resolvedAuth = resolveAuth(newAuth, childDetails, getParentChain, getData);
      const { headers, queryParams } = parseAuth(resolvedAuth, resolver);
      const headersContent = Object.fromEntries(headers);

      const queryParamsContent: SimpleKeyValuePair[] = [];
      queryParams.forEach(({ key, value }) => {
        queryParamsContent.push({ key, value });
      });
      purgeAndAdd(AutogeneratedFieldsNamespace.AUTH, headersContent, queryParamsContent);

      setEntry((prevEntry) => {
        const updatedEntry = { ...prevEntry };
        updatedEntry.auth = newAuth;
        return updatedEntry;
      });
    },
    [apiEntryDetails?.collectionId, apiEntryDetails?.id, getData, getParentChain, purgeAndAdd, resolver]
  );

  const onUrlInputEnterPressed = useCallback((evt: KeyboardEvent) => {
    (evt.target as HTMLInputElement).blur();
  }, []);

  const handleTestResultRefresh = useCallback(async () => {
    try {
      const result = await httpRequestExecutor.rerun(apiEntryDetails?.id, entry);
      if (result.status === RQAPI.ExecutionStatus.SUCCESS) {
        setEntry((entry) => ({
          ...entry,
          testResults: result.artifacts.testResults,
        }));
      } else {
        setError(result.error);
      }
    } catch (error) {
      toast.error("Something went wrong while refreshing test results");
    }
  }, [httpRequestExecutor, apiEntryDetails?.id, entry]);

  const handleRevertChanges = () => {
    setEntry(apiEntryDetails?.data);
  };

  const handleOnUrlChange = (value: string, params: KeyValuePair[]) => {
    setEntry((prevEntry) => ({
      ...prevEntry,
      request: { ...prevEntry.request, url: value, queryParams: params },
    }));
    setUnsaved(true);
  };

  const enableHotkey = getIsActive();

  return isExtensionEnabled ? (
    <div className="api-client-view http-client-view">
      <div className="api-client-header-container">
        <RoleBasedComponent
          permission="create"
          resource="api_client_request"
          fallback={
            <Conditional condition={user.loggedIn && !openInModal && hasUnsavedChanges}>
              <RevertViewModeChangesAlert
                title="As a viewer, You can modify and test APIs, but cannot save updates."
                callback={handleRevertChanges}
              />
            </Conditional>
          }
        />
        <div className="api-client-header-container__header">
          <div className="api-client-breadcrumb-container">
            <ApiClientBreadCrumb
              id={apiEntryDetails.id}
              openInModal={openInModal}
              placeholder="Untitled request"
              name={apiEntryDetails?.name}
              onRecordNameUpdate={setRequestName}
              autoFocus={getIsNew()}
              onBlur={() => {
                setIsNew(false);
                handleRecordNameUpdate();
              }}
              breadCrumbType={BreadcrumbType.API_REQUEST}
            />

            <ClientCodeButton
              requestPreparer={() =>
                httpRequestExecutor.requestPreparer.prepareRequest(apiEntryDetails?.id, entry).preparedEntry.request
              }
            />
          </div>

          <div className="api-client-header__url">
            <Space.Compact className="api-client-url-container">
              <Select
                popupClassName="api-request-method-selector"
                className="api-request-method-selector"
                options={requestMethodOptions}
                value={entry.request.method}
                onChange={setMethod}
              />
              <HttpApiClientUrl
                url={entry.request.url}
                onUrlChange={handleOnUrlChange}
                onEnterPress={onUrlInputEnterPressed}
                currentEnvironmentVariables={scopedVariables}
              />
            </Space.Compact>
            <RQButton
              showHotKeyText
              onClick={onSendButtonClick}
              hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SEND_REQUEST.hotKey}
              type="primary"
              className="text-bold"
              enableHotKey={enableHotkey}
              disabled={
                !entry.request.url ||
                (appMode === "EXTENSION" && entry.request.contentType === RequestContentType.MULTIPART_FORM)
              }
            >
              Send
            </RQButton>

            <Conditional condition={!openInModal}>
              <RBACButton
                disabled={
                  !hasUnsavedChanges ||
                  (appMode === "EXTENSION" && entry.request.contentType === RequestContentType.MULTIPART_FORM)
                }
                permission="create"
                resource="api_client_request"
                showHotKeyText
                hotKey={KEYBOARD_SHORTCUTS.API_CLIENT.SAVE_REQUEST.hotKey}
                onClick={onSaveButtonClick}
                loading={isRequestSaving}
                tooltipTitle="Saving is not allowed in view-only mode. You can update and view changes but cannot save them."
                enableHotKey={enableHotkey}
              >
                Save
              </RBACButton>
            </Conditional>
          </div>
        </div>
      </div>
      <BottomSheetLayout
        layout={SheetLayout.SPLIT}
        bottomSheet={
          <ApiClientBottomSheet
            response={entry.response}
            testResults={testResults ?? []}
            onGenerateTests={handleGenerateTests}
            isGeneratingTests={isGeneratingTests}
            canGenerateTests={canGenerateTests}
            isLoading={isLoadingResponse}
            isFailed={isFailed}
            isLongRequest={isLongRequest}
            isRequestCancelled={isRequestCancelled}
            onCancelRequest={handleCancelRequest}
            handleTestResultRefresh={handleTestResultRefresh}
            error={error}
            onDismissError={handleDismissError}
            warning={warning}
            executeRequest={onSendButtonClick}
          />
        }
        initialSizes={sheetPlacement === BottomSheetPlacement.BOTTOM ? [60, 40] : [50, 50]}
      >
        <div
          className={`api-client-body ${
            sheetPlacement === BottomSheetPlacement.BOTTOM ? "api-client-body__vertical" : "api-client-body__horizontal"
          }`}
        >
          <HttpRequestTabs
            error={error}
            requestEntry={entry}
            requestId={apiEntryDetails?.id}
            collectionId={apiEntryDetails?.collectionId}
            setRequestEntry={setRequestEntry}
            handleAuthChange={handleAuthChange}
            focusPostResponseScriptEditor={focusPostResponseScriptEditor}
            scriptEditorVersion={scriptEditorVersion}
          />
        </div>
      </BottomSheetLayout>
    </div>
  ) : (
    <div className="w-full">
      <ExtensionDeactivationMessage />
    </div>
  );
};

const WithQueryParamsProvider = (Component: React.ComponentType<any>): React.FC<Props> => {
  const WrappedComponent: React.FC = (props: any) => {
    const record = useAPIRecordsStore().getState().getData(props.apiEntryDetails.id) as RQAPI.ApiClientRecord;
    const entry = (record?.data as RQAPI.HttpApiEntry) || props.apiEntryDetails.data;

    return (
      <ErrorBoundary boundaryId="http-client-view-error-boundary">
        <PathVariablesProvider pathVariables={entry.request?.pathVariables ?? []}>
          <QueryParamsProvider entry={entry}>
            <Component {...props} />
          </QueryParamsProvider>
        </PathVariablesProvider>
      </ErrorBoundary>
    );
  };

  return WrappedComponent;
};

export default React.memo(WithQueryParamsProvider(HttpClientView));
