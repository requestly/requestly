import React, { useMemo, useState, useRef, useCallback, useEffect } from "react";
import { useScopedVariables } from "features/apiClient/helpers/variableResolver/variable-resolver";
import { KeyValueTable } from "../KeyValueTable/KeyValueTable";
import { AutoGeneratedTable } from "../KeyValueTable/AutoGeneratedTable";
import { BufferedGraphQLRecordEntity, BufferedHttpRecordEntity } from "features/apiClient/slices/entities";
import { useApiClientSelector } from "features/apiClient/slices/hooks/base.hooks";
import { useAutoGeneratedFields } from "features/apiClient/slices/autoGeneratedFields/selectors";
import { KeyValueFormType, KeyValuePair } from "features/apiClient/types";
import {
  KeyValueTableSplitLayout,
  useKeyValueTableSplitLayout,
} from "../KeyValueTable/KeyValueTableSplitLayout/KeyValueTableSplitLayout";
import { AutoScrollContainer } from "../AutoScrollContainer";

interface HeadersTableProps {
  entity: BufferedHttpRecordEntity | BufferedGraphQLRecordEntity;
}

function HeadersTableContent(props: {
  entity: BufferedHttpRecordEntity | BufferedGraphQLRecordEntity;
  headerContent: React.ReactNode;
}) {
  const { entity, headerContent } = props;
  const scopedVariables = useScopedVariables(entity.meta.referenceId);
  const [showDescription, setShowDescription] = useState(false);
  const headers = useApiClientSelector((s) => entity.getHeaders(s));
  const scrollTargetRef = useRef<HTMLDivElement>(null);

  const layoutContext = useKeyValueTableSplitLayout();

  const handleChange = useCallback(
    (updated: KeyValuePair[]) => {
      entity.setHeaders(updated);
    },
    [entity]
  );

  useEffect(() => {
    if (layoutContext?.bulkEditorState?.title === "Headers") {
      layoutContext.syncBulkEditor({
        data: headers,
        onChange: handleChange,
        title: "Headers",
      });
    }
  }, [headers, handleChange, layoutContext]);

  const handleSetShowBulkEdit = useCallback(
    (show: boolean) => {
      if (!layoutContext) return;
      if (show) {
        layoutContext.openBulkEditor({
          data: headers,
          onChange: handleChange,
          title: "Headers",
        });
      } else {
        layoutContext.closeBulkEditor();
      }
    },
    [layoutContext, headers, handleChange]
  );

  return (
    <div className="key-value-table" style={{ display: "flex", flexDirection: "column", flex: 1, overflow: "hidden" }}>
      <AutoScrollContainer trigger={headers.length} scrollTargetRef={scrollTargetRef}>
        {headerContent}
        <KeyValueTable
          data={headers}
          variables={scopedVariables}
          onChange={handleChange}
          config={{ checkInvalidCharacter: true }}
          extraColumns={{
            description: {
              visible: showDescription,
              onToggle: setShowDescription,
            },
            dataType: { visible: true },
          }}
          tableType={KeyValueFormType.HEADERS}
          setShowBulkEditPanel={handleSetShowBulkEdit}
        />
        <div ref={scrollTargetRef} />
      </AutoScrollContainer>
    </div>
  );
}

export const HeadersTable: React.FC<HeadersTableProps> = React.memo(({ entity }) => {
  const { headers: autogeneratedHeaders } = useAutoGeneratedFields(entity);
  const headerContent = useMemo(
    () => (autogeneratedHeaders.length > 0 ? <AutoGeneratedTable data={autogeneratedHeaders} type="headers" /> : null),
    [autogeneratedHeaders]
  );

  return (
    <div className="table-container" style={{ height: "100%", display: "flex", flexDirection: "column" }}>
      <div className="table-content" style={{ height: "100%", display: "flex", flexDirection: "column", minHeight: 0 }}>
        <KeyValueTableSplitLayout>
          <HeadersTableContent entity={entity} headerContent={headerContent} />
        </KeyValueTableSplitLayout>
      </div>
    </div>
  );
});
