import React, { useMemo, useState, useRef, useCallback, useEffect } from "react";
import { useScopedVariables } from "features/apiClient/helpers/variableResolver/variable-resolver";
import { KeyValueTable } from "../KeyValueTable/KeyValueTable";
import { AutoGeneratedTable } from "../KeyValueTable/AutoGeneratedTable";
import { BufferedGraphQLRecordEntity, BufferedHttpRecordEntity } from "features/apiClient/slices/entities";
import { useApiClientSelector } from "features/apiClient/slices/hooks/base.hooks";
import { useAutoGeneratedFields } from "features/apiClient/slices/autoGeneratedFields/selectors";
import { KeyValueFormType, KeyValuePair } from "features/apiClient/types";
import {
  KeyValueTableSplitLayout,
  useKeyValueTableSplitLayout,
} from "../KeyValueTable/KeyValueTableSplitLayout/KeyValueTableSplitLayout";

interface HeadersTableProps {
  entity: BufferedHttpRecordEntity | BufferedGraphQLRecordEntity;
}

function HeadersTableContent(props: {
  entity: BufferedHttpRecordEntity | BufferedGraphQLRecordEntity;
  headerContent: React.ReactNode;
}) {
  const { entity, headerContent } = props;
  const scopedVariables = useScopedVariables(entity.meta.referenceId);
  const [showDescription, setShowDescription] = useState(false);
  const headers = useApiClientSelector((s) => entity.getHeaders(s));
  const scrollTargetRef = useRef<HTMLDivElement>(null);

  const layoutContext = useKeyValueTableSplitLayout();

  const prevLength = useRef(headers.length);
  useEffect(() => {
    if (headers.length !== prevLength.current) {
      scrollTargetRef.current?.scrollIntoView({ behavior: "smooth", block: "nearest" });
      prevLength.current = headers.length;
    }
  }, [headers.length]);

  const handleChange = useCallback(
    (updated: KeyValuePair[]) => {
      entity.setHeaders(updated);
    },
    [entity]
  );

  useEffect(() => {
    if (layoutContext?.bulkEditorState?.title === "Headers") {
      layoutContext.syncBulkEditor({
        data: headers,
        onChange: handleChange,
        title: "Headers",
      });
    }
  }, [headers, handleChange, layoutContext]);

  const handleSetShowBulkEdit = useCallback(
    (show: boolean) => {
      if (!layoutContext) return;
      if (show) {
        layoutContext.openBulkEditor({
          data: headers,
          onChange: handleChange,
          title: "Headers",
        });
      } else {
        layoutContext.closeBulkEditor();
      }
    },
    [layoutContext, headers, handleChange]
  );

  return (
    <>
      {headerContent}
      <KeyValueTable
        data={headers}
        variables={scopedVariables}
        onChange={handleChange}
        config={{ checkInvalidCharacter: true }}
        extraColumns={{
          description: {
            visible: showDescription,
            onToggle: setShowDescription,
          },
          dataType: { visible: true },
        }}
        tableType={KeyValueFormType.HEADERS}
        setShowBulkEditPanel={handleSetShowBulkEdit}
      />
      <div ref={scrollTargetRef} />
    </>
  );
}

export const HeadersTable: React.FC<HeadersTableProps> = React.memo(({ entity }) => {
  const { headers: autogeneratedHeaders } = useAutoGeneratedFields(entity);
  const headerContent = useMemo(
    () => (autogeneratedHeaders.length > 0 ? <AutoGeneratedTable data={autogeneratedHeaders} type="headers" /> : null),
    [autogeneratedHeaders]
  );

  return (
    <KeyValueTableSplitLayout>
      <HeadersTableContent entity={entity} headerContent={headerContent} />
    </KeyValueTableSplitLayout>
  );
});
