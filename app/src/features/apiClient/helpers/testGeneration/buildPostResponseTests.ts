// Utility to build autogenerated Post Response test script block
// This should be idempotent: if block already exists, do not duplicate.
// Markers allow safe identification & future removal if needed.

/*
 Autogenerated Tests Block Structure:

 // ==== RQ_AUTOGEN_TESTS:START ====

  rq.test("Status code is 201", () => {
    rq.response.to.have.status(201);
  });

  rq.test("Request method is POST", () => {
    rq.expect(rq.request.method).to.equal("POST");
  });

  rq.test("Response has valid JSON body", () => {
    rq.response.to.have.jsonBody();
  });

  rq.test("Response body is JSON object", () => {
    const parsed = JSON.parse(rq.response.body);
    rq.expect(parsed).to.be.an("object").and.not.to.be.an("array");
  });

 // ==== RQ_AUTOGEN_TESTS:END ====
*/

export const AUTOGEN_TESTS_START = "// ==== RQ_AUTOGEN_TESTS:START ===="; // DO NOT CHANGE markers; used for detection & stripping
export const AUTOGEN_TESTS_END = "// ==== RQ_AUTOGEN_TESTS:END ====";
export const AUTOGEN_TESTS_INFO_PREFIX = "// ==== RQ_AUTOGEN_TESTS:INFO"; // we add metadata after this

interface BuildTestsOptions {
  method?: string;
  status?: number;
  hasJsonObjectBody?: boolean;
}

// Returns true if script already contains the autogenerated tests block
export function hasAutogeneratedTests(script: string | undefined): boolean {
  if (!script) return false;
  return script.includes(AUTOGEN_TESTS_START) && script.includes(AUTOGEN_TESTS_END);
}

// Build block lines; only include tests when underlying data available.
// Generates up to 4 common POST tests: status, method, valid JSON, JSON object.
export function buildAutogeneratedTestsBlock(opts: BuildTestsOptions): string {
  const { method, status, hasJsonObjectBody } = opts;
  const lines: string[] = [];
  lines.push(AUTOGEN_TESTS_START);

  if (typeof status === "number") {
    lines.push(`rq.test("Status code is ${status}", () => {\n  rq.response.to.have.status(${status});\n});`);
  }

  if (method) {
    lines.push(
      `rq.test("Request method is ${method}", () => {\n  rq.expect(rq.request.method).to.equal("${method}");\n});`
    );
  }

  if (hasJsonObjectBody) {
    lines.push(`rq.test("Response has valid JSON body", () => {\n  rq.response.to.have.jsonBody();\n});`);
    lines.push(
      `rq.test("Response body is JSON object", () => {\n  const parsed = JSON.parse(rq.response.body);\n  rq.expect(parsed).to.be.an("object").and.not.to.be.an("array");\n});`
    );
  }

  lines.push(AUTOGEN_TESTS_END);
  return lines.join("\n\n");
}

// Inject block at end of existing script (or create fresh script). Returns new script.
export function injectAutogeneratedTests(script: string | undefined, block: string): string {
  if (!script || !script.trim()) {
    return `${block}\n`;
  }
  // Avoid double append
  if (hasAutogeneratedTests(script)) {
    return script; // idempotent
  }
  // Append with spacing
  const trimmed = script.endsWith("\n") ? script : script + "\n";
  return `${trimmed}\n${block}\n`;
}

export function stripAutogeneratedTests(script: string | undefined): string {
  if (!script) return "";
  if (!hasAutogeneratedTests(script)) return script;
  const startIndex = script.indexOf(AUTOGEN_TESTS_START);
  const endIndex = script.indexOf(AUTOGEN_TESTS_END);
  if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) return script; // malformed, return original
  const afterEnd = endIndex + AUTOGEN_TESTS_END.length;
  const without = script.slice(0, startIndex) + script.slice(afterEnd);
  return without.trim();
}
