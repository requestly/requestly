// Utility to build autogenerated Post Response test script block
// This should be idempotent: if block already exists, do not duplicate.
// Markers allow safe identification & future removal if needed.

/*
 Autogenerated Tests Block Structure:

 // ==== RQ_AUTOGEN_TESTS:START ====


  rq.test("Response time < 60s", () => {
   rq.expect(response.time < 60000, "Expected response time < 60s but got " + response.time + "ms");
 });

  rq.test("Response has JSON object body", () => {
   const contentType = (response.headers || []).find(h => h.key?.toLowerCase() === "content-type")?.value || "";
   const isJson = /application\/json/i.test(contentType);
   let parsed;
   try { parsed = isJson ? JSON.parse(response.body) : null; } catch(e) {}
   rq.expect(parsed && typeof parsed === "object" && !Array.isArray(parsed), "Expected JSON object body");
 });

  rq.test("Request method is GET", () => {
   rq.expect(request.method === "GET", "Expected method GET but got " + request.method);
 });
 // ==== RQ_AUTOGEN_TESTS:END ====
*/

export const AUTOGEN_TESTS_START = "// ==== RQ_AUTOGEN_TESTS:START ===="; // DO NOT CHANGE markers; used for detection & stripping
export const AUTOGEN_TESTS_END = "// ==== RQ_AUTOGEN_TESTS:END ====";
export const AUTOGEN_TESTS_INFO_PREFIX = "// ==== RQ_AUTOGEN_TESTS:INFO"; // we add metadata after this

interface BuildTestsOptions {
  method: string;
  status: number | undefined;
  responseTimeMs: number | undefined;
  hasJsonObjectBody: boolean;
}

// Returns true if script already contains the autogenerated tests block
export function hasAutogeneratedTests(script: string | undefined): boolean {
  if (!script) return false;
  return script.includes(AUTOGEN_TESTS_START) && script.includes(AUTOGEN_TESTS_END);
}

// Build block lines; only include expections when underlying data available.
export function buildAutogeneratedTestsBlock(opts: BuildTestsOptions): string {
  const { method, status, responseTimeMs, hasJsonObjectBody } = opts;
  const lines: string[] = [];
  lines.push(AUTOGEN_TESTS_START);

  if (typeof status === "number") {
    lines.push(
      `rq.test("Status code is ${status}", () => {\n  rq.expect(rq.response.status === ${status}, "Expected status to be ${status} but got " + rq.response.status);\n});`
    );
  }

  if (typeof responseTimeMs === "number") {
    lines.push(
      `rq.test("Response time < 60s", () => {\n  rq.expect(rq.response.time < 60000, "Expected response time < 60s but got " + rq.response.time + "ms");\n});`
    );
  }

  if (hasJsonObjectBody) {
    lines.push(
      `rq.test("Response has JSON object body", () => {\n  const contentType = (rq.response.headers || []).find(h => h.key?.toLowerCase() === "content-type")?.value || "";\n  const isJson = /application\\/json/i.test(contentType);\n  let parsed;\n  try { parsed = isJson ? JSON.parse(rq.response.body) : null; } catch(e) {}\n  rq.expect(parsed && typeof parsed === "object" && !Array.isArray(parsed), "Expected JSON object body");\n});`
    );
  }

  if (method) {
    lines.push(
      `rq.test("Request method is ${method}", () => {\n  rq.expect(rq.request.method === "${method}", "Expected method ${method} but got " + rq.request.method);\n});`
    );
  }

  lines.push(AUTOGEN_TESTS_END);
  return lines
    .join("\n\n")
    .replace(/RQ\.test/g, "rq.test")
    .replace(/RQ\.expect/g, "rq.expect");
}

// Inject block at end of existing script (or create fresh script). Returns new script.
export function injectAutogeneratedTests(script: string | undefined, block: string): string {
  if (!script || !script.trim()) {
    return `${block}\n`;
  }
  // Avoid double append
  if (hasAutogeneratedTests(script)) {
    return script; // idempotent
  }
  // Append with spacing
  const trimmed = script.endsWith("\n") ? script : script + "\n";
  return `${trimmed}\n${block}\n`;
}

export function stripAutogeneratedTests(script: string | undefined): string {
  if (!script) return "";
  if (!hasAutogeneratedTests(script)) return script;
  const startIndex = script.indexOf(AUTOGEN_TESTS_START);
  const endIndex = script.indexOf(AUTOGEN_TESTS_END);
  if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) return script; // malformed, return original
  const afterEnd = endIndex + AUTOGEN_TESTS_END.length;
  const without = script.slice(0, startIndex) + script.slice(afterEnd);
  return without.trim();
}
