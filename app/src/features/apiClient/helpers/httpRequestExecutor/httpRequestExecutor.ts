import { AbortReason, FormDropDownOptions, KeyValuePair, RequestContentType, RQAPI } from "../../types";
import { addUrlSchemeIfMissing, makeRequest, queryParamsToURLString } from "../../screens/apiClient/utils";
import { APIClientWorkloadManager } from "../modules/scriptsV2/workloadManager/APIClientWorkloadManager";
import { updateRequestWithAuthOptions } from "../auth";
import {
  PostResponseScriptWorkload,
  PreRequestScriptWorkload,
  WorkResultType,
} from "../modules/scriptsV2/workloadManager/workLoadTypes";
import { BaseSnapshot, SnapshotForPostResponse, SnapshotForPreRequest } from "./snapshotTypes";
import {
  trackScriptExecutionCompleted,
  trackScriptExecutionFailed,
  trackScriptExecutionStarted,
} from "../modules/scriptsV2/analytics";
import { isMethodSupported, isOnline, isUrlProtocolValid, isUrlValid } from "./httpRequestExecutorHelpers";
import { isEmpty } from "lodash";
import { DEFAULT_SCRIPT_VALUES } from "features/apiClient/constants";
import { UserAbortError } from "features/apiClient/errors/UserAbortError/UserAbortError";
import { CONSTANTS as GLOBAL_CONSTANTS } from "@requestly/requestly-core";
import { StoreApi } from "zustand";
import { AutogeneratedFieldsStore } from "features/apiClient/store/autogenerateStore";
import { ApiClientFeatureContext } from "features/apiClient/store/apiClientFeatureContext/apiClientFeatureContext.store";
import { renderVariables } from "backend/environment/utils";
import {
  getApiClientEnvironmentsStore,
  getApiClientRecordsStore,
  getApiClientRecordStore,
} from "features/apiClient/commands/store.utils";
import { parseEnvironmentState } from "features/apiClient/commands/environments/utils";
import { NativeError } from "errors/NativeError";
import { apiClientFileStore } from "features/apiClient/store/apiClientFilesStore";
import { trackRequestFailed } from "modules/analytics/events/features/apiClient";
import { getParsedRuntimeVariables } from "features/apiClient/store/runtimeVariables/utils";

type InternalFunctions = {
  postScriptExecutionCallback(state: any): Promise<void>;
};

enum RQErrorHeaderValue {
  DNS_RESOLUTION_ERROR = "ERR_NAME_NOT_RESOLVED",
}

enum RequestErrorMessage {
  DNS_RESOLUTION_ERROR = "Could not connect. Please check if the server is up and the address can be resolved.",
}

export class HttpRequestExecutor {
  private abortController: AbortController;
  private entryDetails: RQAPI.HttpApiEntry;
  private internalFunctions: InternalFunctions;
  private renderedVariables: Record<string, unknown> = {};
  constructor(
    private recordId: string,
    private ctx: ApiClientFeatureContext,
    private appMode: string,
    private workloadManager: APIClientWorkloadManager,
    readonly autoGeneratedStore: StoreApi<AutogeneratedFieldsStore>
  ) {}

  prepareRequest() {
    this.entryDetails.testResults = [];
    this.entryDetails.request.url = queryParamsToURLString(
      this.entryDetails.request.queryParams,
      this.entryDetails.request.url
    );
    this.abortController = new AbortController();
    this.entryDetails.request.queryParams = [];
    this.renderedVariables = {};

    const { renderedVariables, result } = renderVariables(this.entryDetails, this.recordId, this.ctx);

    this.entryDetails = result;

    this.renderedVariables = renderedVariables;

    const { getAllHeaders, getAllQueryParams } = this.autoGeneratedStore.getState();
    const headers = getAllHeaders().map((kv, index) => ({ ...kv, id: index, isEnabled: true }));
    const queryParams = getAllQueryParams().map((kv, index) => ({ ...kv, id: index, isEnabled: true }));

    this.entryDetails.request.headers = updateRequestWithAuthOptions(this.entryDetails.request.headers, headers);
    this.entryDetails.request.queryParams = updateRequestWithAuthOptions(
      this.entryDetails.request.queryParams,
      queryParams
    );

    return this.entryDetails.request;
  }

  private buildBaseSnapshot(): BaseSnapshot {
    const { activeEnvironment, globalEnvironment } = getApiClientEnvironmentsStore(this.ctx).getState();
    const globalEnvironmentState = globalEnvironment.getState();
    const globalVariables = parseEnvironmentState(globalEnvironmentState).variables;
    const environmentVariables = activeEnvironment ? parseEnvironmentState(activeEnvironment.getState()).variables : {};
    const variables = getParsedRuntimeVariables();
    const collectionVariables = (() => {
      const parent = getApiClientRecordsStore(this.ctx).getState().getParent(this.recordId);
      if (!parent) {
        return {};
      }
      const recordState = getApiClientRecordStore(this.ctx, parent)?.getState();
      if (!recordState || recordState.type !== RQAPI.RecordType.COLLECTION) {
        throw new NativeError("Expected value to be present and be a collection!").addContext({
          recordId: parent,
        });
      }

      return Object.fromEntries(recordState.collectionVariables.getState().getAll());
    })();
    return {
      global: globalVariables,
      collectionVariables,
      environment: environmentVariables,
      variables,
    };
  }

  private buildPreRequestSnapshot(): SnapshotForPreRequest {
    return {
      ...this.buildBaseSnapshot(),
      request: this.entryDetails.request,
    };
  }

  private buildPostResponseSnapshot(): SnapshotForPostResponse {
    const response = this.entryDetails.response;
    if (!response) {
      throw new Error("Can not build post response snapshot without response!");
    }
    return {
      ...this.buildBaseSnapshot(),
      request: this.entryDetails.request,
      response,
    };
  }

  private async validateMultipartFormBodyFiles(): Promise<{
    invalidFiles: string[];
  }> {
    if (this.entryDetails.request.contentType === RequestContentType.MULTIPART_FORM) {
      const fileBodies = (this.entryDetails.request.body as RQAPI.MultipartFormBody)?.filter(
        (body) => body.type === FormDropDownOptions.FILE && typeof body.value !== "string"
      );

      const validateFile = apiClientFileStore.getState().isFilePresentLocally;

      const invalidFiles: string[] = [];

      for (const body of fileBodies) {
        if (Array.isArray(body.value)) {
          const filesExistenceCheckerResponse = await Promise.all(
            body.value.map(async (file) => ({
              id: file.id,
              exists: await validateFile(file.id),
            }))
          );

          filesExistenceCheckerResponse.forEach(({ id, exists }) => {
            if (!exists) {
              invalidFiles.push(id);
            }
          });
        }
      }

      return { invalidFiles };
    }
  }

  private preValidateRequest() {
    /*
    Header is checked if it is unresolved at this step
    Check flags invalid characters & incomplete/undeclared variables
    For Ex: {{RQ_CLIENT_ID}} not defined in environment table & {{RQ_CLIENT_ID} which is invalid expression
    */
    const INVALID_HEADER_CHARACTERS = /[^!#$%&'*+\-.0-9A-Z^_a-z|~]/;
    const invalidHeader = this.entryDetails?.request?.headers?.find((header) => {
      return INVALID_HEADER_CHARACTERS.test(header.key);
    });

    if (!this.entryDetails.request.url) {
      throw new Error("Request URL cannot be empty!");
    }

    if (!isOnline()) {
      throw new Error("Looks like you are offline. Please check your network connection.");
    }

    if (!isMethodSupported(this.entryDetails.request.method)) {
      throw new Error(`Unsupported request method: ${this.entryDetails.request.method}`);
    }

    if (!isUrlValid(this.entryDetails.request.url)) {
      throw new Error(`Invalid URL: ${this.entryDetails.request.url}`);
    }

    if (!isUrlProtocolValid(this.entryDetails.request.url)) {
      throw new Error(`Invalid URL protocol: ${this.entryDetails.request.url}`);
    }
    if (invalidHeader) {
      throw new Error(`Invalid header key: "${invalidHeader.key}". Header keys must not contain special characters.`);
    }
  }

  private getEmptyRenderedVariables(): string[] {
    if (isEmpty(this.renderedVariables)) {
      return [];
    }

    return Object.keys(this.renderedVariables).filter(
      (key) => this.renderedVariables[key] === undefined || this.renderedVariables[key] === ""
    );
  }

  private buildExecutionErrorObject(error: any, source: string, type: RQAPI.ApiClientErrorType): RQAPI.ExecutionError {
    const errorObject: RQAPI.ExecutionError = {
      type,
      source,
      name: error.name || "Error",
      message: error.message,
    };
    if (error instanceof UserAbortError) {
      errorObject.reason = AbortReason.USER_CANCELLED;
    }

    return errorObject;
  }

  private buildErrorObjectFromHeader(header: KeyValuePair): RQAPI.ExecutionError {
    switch (header.value) {
      case RQErrorHeaderValue.DNS_RESOLUTION_ERROR:
        return this.buildExecutionErrorObject(
          {
            name: "Error",
            message: RequestErrorMessage.DNS_RESOLUTION_ERROR,
            type: RQAPI.ApiClientErrorType.CORE,
            source: "request",
          },
          "request",
          RQAPI.ApiClientErrorType.CORE
        );
      default:
        return this.buildExecutionErrorObject(
          {
            name: "Error",
            message: "Failed to fetch",
            type: RQAPI.ApiClientErrorType.CORE,
            source: "request",
          },
          "request",
          RQAPI.ApiClientErrorType.CORE
        );
    }
  }

  updateEntryDetails(entryDetails: {
    entry: RQAPI.HttpApiEntry;
    collectionId: RQAPI.ApiClientRecord["collectionId"];
    recordId: RQAPI.ApiClientRecord["id"];
  }) {
    this.entryDetails = entryDetails.entry;
  }

  updateInternalFunctions(internalFunctions: InternalFunctions) {
    this.internalFunctions = internalFunctions;
  }

  async executePreRequestScript(callback: (state: any) => Promise<void>) {
    return this.workloadManager.execute(
      new PreRequestScriptWorkload(this.entryDetails.scripts.preRequest, this.buildPreRequestSnapshot(), callback),
      this.abortController.signal
    );
  }

  async executePostResponseScript(callback: (state: any) => Promise<void>) {
    return this.workloadManager.execute(
      new PostResponseScriptWorkload(
        this.entryDetails.scripts.postResponse,
        this.buildPostResponseSnapshot(),
        callback
      ),
      this.abortController.signal
    );
  }

  async execute(): Promise<RQAPI.ExecutionResult> {
    //clear the previous response before execution
    this.entryDetails.response = null;

    if (this.entryDetails.request.contentType === RequestContentType.MULTIPART_FORM) {
      const { invalidFiles } = await this.validateMultipartFormBodyFiles();
      const isInvalid = invalidFiles.length > 0;
      if (isInvalid) {
        trackRequestFailed(RQAPI.ApiClientErrorType.MISSING_FILE);

        return {
          executedEntry: { ...this.entryDetails },
          status: RQAPI.ExecutionStatus.ERROR,
          error: {
            name: "Error",
            message: "Request not sent -- some files are missing",
            reason:
              invalidFiles.length > 1
                ? "Some files appear to be missing or unavailable on your device. Please upload them again to proceed."
                : "The file seems to have been moved or deleted from your device. Please upload it again to continue.",
            type: RQAPI.ApiClientErrorType.MISSING_FILE,
            source: "request",
          },
        };
      }
    }

    this.prepareRequest();
    this.entryDetails.request.url = addUrlSchemeIfMissing(this.entryDetails.request.url);

    try {
      this.preValidateRequest();
    } catch (err) {
      const error = this.buildExecutionErrorObject(err, "request", RQAPI.ApiClientErrorType.PRE_VALIDATION);
      return {
        executedEntry: { ...this.entryDetails },
        status: RQAPI.ExecutionStatus.ERROR,
        error,
      };
    }
    let preRequestScriptResult;
    let responseScriptResult;

    if (
      this.entryDetails.scripts.preRequest.length &&
      this.entryDetails.scripts.preRequest !== DEFAULT_SCRIPT_VALUES.preRequest
    ) {
      trackScriptExecutionStarted(RQAPI.ScriptType.PRE_REQUEST);
      preRequestScriptResult = await this.executePreRequestScript(this.internalFunctions.postScriptExecutionCallback);

      if (preRequestScriptResult.type === WorkResultType.ERROR) {
        trackScriptExecutionFailed(
          RQAPI.ScriptType.PRE_REQUEST,
          preRequestScriptResult.error.type,
          preRequestScriptResult.error.message
        );
        const error = this.buildExecutionErrorObject(
          preRequestScriptResult.error,
          "Pre-request script",
          RQAPI.ApiClientErrorType.SCRIPT
        );

        return {
          executedEntry: {
            ...this.entryDetails,
          },
          status: RQAPI.ExecutionStatus.ERROR,
          error,
        };
      }
    }

    try {
      const response = await makeRequest(this.appMode, this.entryDetails.request, this.abortController.signal);
      this.entryDetails.response = response;
      const rqErrorHeader = response?.headers?.find((header) => header.key === "x-rq-error");

      if (rqErrorHeader) {
        return {
          status: RQAPI.ExecutionStatus.ERROR,
          executedEntry: { ...this.entryDetails, response: null },
          error: this.buildErrorObjectFromHeader(rqErrorHeader),
        };
      }
    } catch (err) {
      return {
        status: RQAPI.ExecutionStatus.ERROR,
        executedEntry: { ...this.entryDetails, response: null },
        error: this.buildExecutionErrorObject(
          {
            ...err,
            message:
              this.appMode === GLOBAL_CONSTANTS.APP_MODES.DESKTOP
                ? err.message
                : RequestErrorMessage.DNS_RESOLUTION_ERROR,
          },
          "request",
          RQAPI.ApiClientErrorType.CORE
        ),
      };
    }

    if (
      this.entryDetails.scripts.postResponse.length &&
      this.entryDetails.scripts.preRequest !== DEFAULT_SCRIPT_VALUES.postResponse
    ) {
      trackScriptExecutionStarted(RQAPI.ScriptType.POST_RESPONSE);
      responseScriptResult = await this.executePostResponseScript(this.internalFunctions.postScriptExecutionCallback);

      if (responseScriptResult.type === WorkResultType.SUCCESS) {
        trackScriptExecutionCompleted(RQAPI.ScriptType.POST_RESPONSE);
      }

      if (responseScriptResult.type === WorkResultType.ERROR) {
        trackScriptExecutionFailed(
          RQAPI.ScriptType.POST_RESPONSE,
          responseScriptResult.error.type,
          responseScriptResult.error.message
        );
        const error = this.buildExecutionErrorObject(
          responseScriptResult.error,
          "Post-response script",
          RQAPI.ApiClientErrorType.SCRIPT
        );

        return {
          status: RQAPI.ExecutionStatus.ERROR,
          executedEntry: this.entryDetails,
          error,
        };
      }
    }

    const executionResult: RQAPI.ExecutionResult = {
      status: RQAPI.ExecutionStatus.SUCCESS,
      executedEntry: {
        ...this.entryDetails,
        testResults: [
          ...(preRequestScriptResult ? preRequestScriptResult.testExecutionResults : []),
          ...(responseScriptResult ? responseScriptResult.testExecutionResults : []),
        ],
      },
    };

    const emptyRenderedVariables = this.getEmptyRenderedVariables();

    if (!isEmpty(emptyRenderedVariables)) {
      executionResult.warning = {
        message: `Following variables used in your request are empty`,
        description: `${emptyRenderedVariables.map((varName) => `"${varName}"`).join(", ")}`,
      };
    }

    return executionResult;
  }

  async rerun(): Promise<RQAPI.RerunResult> {
    const preRequestScriptResult = await this.executePreRequestScript(async () => {});
    if (preRequestScriptResult.type === WorkResultType.ERROR) {
      const error = this.buildExecutionErrorObject(
        preRequestScriptResult.error,
        "Rerun Pre-request script",
        RQAPI.ApiClientErrorType.SCRIPT
      );
      return {
        status: RQAPI.ExecutionStatus.ERROR,
        error,
      };
    }

    const responseScriptResult = await this.executePostResponseScript(async () => {});

    if (responseScriptResult.type === WorkResultType.ERROR) {
      const error = this.buildExecutionErrorObject(
        responseScriptResult.error,
        "Rerun Post-response script",
        RQAPI.ApiClientErrorType.SCRIPT
      );
      return {
        status: RQAPI.ExecutionStatus.ERROR,
        error,
      };
    }

    return {
      status: RQAPI.ExecutionStatus.SUCCESS,
      artifacts: {
        testResults: [
          ...(preRequestScriptResult.testExecutionResults || []),
          ...(responseScriptResult.testExecutionResults || []),
        ],
      },
    };
  }

  abort() {
    this.abortController.abort(AbortReason.USER_CANCELLED);
  }
}
