import { addUrlSchemeIfMissing, queryParamsToURLString, sanitizeEntry } from "../../screens/apiClient/utils";
import { RQAPI } from "../../types";
import { updateRequestWithAuthOptions } from "../auth";
import { cloneDeep, isEmpty } from "lodash";
import { renderTemplate } from "backend/environment/utils";
import { compile } from "path-to-regexp";
import { Scope, getScopedVariables, StoreOverrideConfig } from "../variableResolver/variable-resolver";
import { ExecutionContext } from "./scriptExecutionContext";
import { ApiClientFeatureContext } from "features/apiClient/slices";
import { reduxStore } from "store";
import { makeAutoGeneratedFieldsSelector } from "features/apiClient/slices/autoGeneratedFields/selectors";
import JSON5 from "json5";
import { RequestContentType } from "../../types";
import { VariableData } from "@requestly/shared/types/entities/apiClient";

export class HttpRequestPreparationService {
  constructor(private ctx: ApiClientFeatureContext) {}

  private renderPathVariables(url: string, pathVariables: RQAPI.PathVariable[]): string {
    const variableValues: Record<RQAPI.PathVariable["key"], RQAPI.PathVariable["value"]> = {};

    if (!pathVariables || pathVariables.length === 0) {
      return url;
    }

    pathVariables.forEach((variable) => {
      variableValues[variable.key] = variable.value;
    });

    const normalizedUrl = addUrlSchemeIfMissing(url);

    const urlObject = new URL(normalizedUrl);

    const toPath = compile(urlObject.pathname);
    const renderedPath = toPath(variableValues);

    urlObject.pathname = renderedPath;

    return urlObject.toString();
  }

  /**
   * Converts ExecutionContext to StoreOverrideConfig for use with getScopedVariables
   */
  private buildStoreOverrideFromContext(context: ExecutionContext): StoreOverrideConfig {
    const config: StoreOverrideConfig = {
      runtimeVariables: context.variables,
      activeEnvironmentVariables: context.environment,
      // globalEnvironmentVariablesStore: context.global ? createDummyVariablesStoreFromData(context.global) : undefined,
      // collectionVariablesStore: context.collectionVariables
      //   ? createDummyVariablesStoreFromData(context.collectionVariables)
      //   : undefined,
    };

    return config;
  }

  private getVariables(
    recordId: string,
    config?: {
      storeOverrideConfig?: StoreOverrideConfig;
      scopes?: Scope[];
    }
  ) {
    const scopedVariables = getScopedVariables(
      this.ctx.store.getState(),
      reduxStore.getState().runtimeVariables.entity.variables,
      recordId,
      config
    );
    const variables: Record<string, VariableData> = {};
    for (const key in scopedVariables) {
      const [variableData] = scopedVariables[key]!;
      variables[key] = variableData;
    }
    return {
      scopedVariables,
      variables,
    };
  }

  /**
   * Extracts and merges all variables in execution context using getScopedVariables
   */
  private extractVariablesFromContext(
    recordId: string,
    context: ExecutionContext,
    scopes?: Scope[]
  ): Record<string, VariableData> {
    const storeOverrideConfig = this.buildStoreOverrideFromContext(context);
    return this.getVariables(recordId, { storeOverrideConfig, scopes }).variables;
  }

  /**
   * Renders variables from execution context instead of reading from store
   * Used when we need to use runtime-modified variables (e.g., after pre-request script)
   */
  private renderVariablesFromContext(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    context: ExecutionContext,
    scopes?: Scope[]
  ): { renderedVariables: any; result: RQAPI.HttpApiEntry } {
    const variables = this.extractVariablesFromContext(recordId, context, scopes);
    const { renderedTemplate, renderedVariables } = renderTemplate(entry as any, variables);

    return {
      renderedVariables,
      result: renderedTemplate as RQAPI.HttpApiEntry,
    };
  }

  private renderVariables(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    scopes?: Scope[]
  ): { renderedVariables: any; result: RQAPI.HttpApiEntry } {
    const { variables } = this.getVariables(recordId, { scopes });
    const { renderedTemplate, renderedVariables } = renderTemplate(entry as any, variables);

    return {
      renderedVariables,
      result: renderedTemplate as RQAPI.HttpApiEntry,
    };
  }

  prepareRequest(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    scopes?: Scope[],
    executionContext?: ExecutionContext
  ): {
    renderedVariables: any;
    preparedEntry: RQAPI.HttpApiEntry;
  } {
    const workingEntry = cloneDeep(sanitizeEntry(entry));

    workingEntry.testResults = [];
    workingEntry.request.url = queryParamsToURLString(workingEntry.request.queryParams, workingEntry.request.url);
    workingEntry.request.queryParams = [];

    const { scopedVariables } = this.getVariables(recordId, {
      storeOverrideConfig: executionContext ? this.buildStoreOverrideFromContext(executionContext) : undefined,
      scopes,
    });
    const selector = makeAutoGeneratedFieldsSelector(recordId, scopedVariables, workingEntry);
    const { headers: autoGeneratedHeaders, queryParams: autoGeneratedQueryParams } = selector(
      this.ctx.store.getState()
    );

    workingEntry.request.headers = updateRequestWithAuthOptions(workingEntry.request.headers, autoGeneratedHeaders);
    workingEntry.request.queryParams = updateRequestWithAuthOptions(
      workingEntry.request.queryParams,
      autoGeneratedQueryParams
    );

    const { renderedVariables, result } = (() => {
      if (!isEmpty(executionContext)) {
        return this.renderVariablesFromContext(recordId, workingEntry, executionContext, scopes);
      } else {
        return this.renderVariables(recordId, workingEntry, scopes);
      }
    })();

    const renderedEntry = result;

    renderedEntry.request.url = this.renderPathVariables(
      renderedEntry.request.url,
      renderedEntry.request.pathVariables || []
    );
    renderedEntry.request.url = addUrlSchemeIfMissing(renderedEntry.request.url);
    if (
      renderedEntry.request.body &&
      renderedEntry.request.contentType === RequestContentType.JSON &&
      typeof renderedEntry.request.body === "string"
    ) {
      try {
        // Here we are parsing and then re-stringifying to remove any comments and trailing commas from JSON
        const parsed = JSON5.parse(renderedEntry.request.body);
        renderedEntry.request.body = JSON.stringify(parsed);
      } catch (error) {
        // No op - If parsing fails, we leave the body as it is
      }
    }

    // Hacky Fix - When "" or [] is sent along with POST, fetch send content-type=text/plain by default
    // Ideally body should be undefined in db also
    if (!renderedEntry?.request?.body || renderedEntry.request?.body?.length <= 0) {
      renderedEntry.request.body = undefined;
    }

    return {
      renderedVariables,
      preparedEntry: renderedEntry,
    };
  }
}
