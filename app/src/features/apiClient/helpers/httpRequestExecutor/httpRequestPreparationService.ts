import { StoreApi } from "zustand";
import { addUrlSchemeIfMissing, queryParamsToURLString, sanitizeEntry } from "../../screens/apiClient/utils";
import { ApiClientFeatureContext } from "../../store/apiClientFeatureContext/apiClientFeatureContext.store";
import { AutogeneratedFieldsStore } from "../../store/autogenerateStore";
import { RQAPI } from "../../types";
import { updateRequestWithAuthOptions } from "../auth";
import { cloneDeep } from "lodash";
import { renderVariables as renderVariablesType, renderTemplate } from "backend/environment/utils";
import { compile } from "path-to-regexp";
import { Scope } from "../variableResolver/variable-resolver";
import { ExecutionContext } from "./scriptExecutionContext";
import { VariableData } from "../../store/variables/types";

export class HttpRequestPreparationService {
  constructor(
    private ctx: ApiClientFeatureContext,
    private autoGeneratedStore: StoreApi<AutogeneratedFieldsStore>,
    private renderVariables: typeof renderVariablesType
  ) {}

  private renderPathVariables(url: string, pathVariables: RQAPI.PathVariable[]): string {
    const variableValues: Record<RQAPI.PathVariable["key"], RQAPI.PathVariable["value"]> = {};

    if (!pathVariables || pathVariables.length === 0) {
      return url;
    }

    pathVariables.forEach((variable) => {
      variableValues[variable.key] = variable.value;
    });

    const urlObject = new URL(url);

    const toPath = compile(urlObject.pathname);
    const renderedPath = toPath(variableValues);

    urlObject.pathname = renderedPath;

    return urlObject.toString();
  }

  /**
   * Extracts and merges all variables from execution context into a flat structure
   * Priority order (lowest to highest): global -> collection -> environment -> runtime
   */
  private extractVariablesFromContext(context: ExecutionContext, scopes?: Scope[]): Record<string, VariableData> {
    const baseVariables = {
      ...context.global,
      ...context.collectionVariables,
      ...context.environment,
      ...context.variables,
    };

    // If scopes are provided (e.g., DATA_FILE for iteration data), merge them with highest priority
    if (scopes && scopes.length > 0) {
      const scopeVariables: Record<string, VariableData> = {};

      for (const [, variableStore] of scopes) {
        const state = variableStore.getState();
        for (const [key, value] of state.data) {
          scopeVariables[key] = value;
        }
      }

      // Scope variables (like data_file) have highest priority
      return {
        ...baseVariables,
        ...scopeVariables,
      };
    }

    return baseVariables;
  }

  /**
   * Renders variables from execution context instead of reading from store
   * Used when we need to use runtime-modified variables (e.g., after pre-request script)
   */
  private renderVariablesFromContext(
    entry: RQAPI.HttpApiEntry,
    context: ExecutionContext,
    scopes?: Scope[]
  ): { renderedVariables: any; result: RQAPI.HttpApiEntry } {
    const variables = this.extractVariablesFromContext(context, scopes);
    const { renderedTemplate, renderedVariables } = renderTemplate(entry as any, variables);

    return {
      renderedVariables,
      result: renderedTemplate as RQAPI.HttpApiEntry,
    };
  }

  prepareRequest(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    scopes?: Scope[],
    executionContext?: ExecutionContext
  ): {
    renderedVariables: any;
    preparedEntry: RQAPI.HttpApiEntry;
  } {
    const workingEntry = cloneDeep(sanitizeEntry(entry));

    workingEntry.testResults = [];
    workingEntry.request.url = queryParamsToURLString(workingEntry.request.queryParams, workingEntry.request.url);
    workingEntry.request.queryParams = [];

    const { getAllHeaders, getAllQueryParams } = this.autoGeneratedStore.getState();

    const headers = getAllHeaders().map((kv, index) => ({ ...kv, id: index, isEnabled: true }));
    const queryParams = getAllQueryParams().map((kv, index) => ({ ...kv, id: index, isEnabled: true }));

    workingEntry.request.headers = updateRequestWithAuthOptions(workingEntry.request.headers, headers);
    workingEntry.request.queryParams = updateRequestWithAuthOptions(workingEntry.request.queryParams, queryParams);

    let renderedVariables: any;
    let result: RQAPI.HttpApiEntry;

    // If execution context is provided, use it instead of reading from store
    // This ensures that runtime variable changes (e.g., from pre-request scripts) are reflected
    if (executionContext) {
      ({ renderedVariables, result } = this.renderVariablesFromContext(workingEntry, executionContext, scopes));
    } else {
      // Fallback to store-based rendering for non-executor flows
      ({ renderedVariables, result } = this.renderVariables(workingEntry, recordId, this.ctx, scopes));
    }

    const renderedEntry = result;

    renderedEntry.request.url = this.renderPathVariables(
      renderedEntry.request.url,
      renderedEntry.request.pathVariables || []
    );
    renderedEntry.request.url = addUrlSchemeIfMissing(renderedEntry.request.url);

    return {
      renderedVariables,
      preparedEntry: renderedEntry,
    };
  }
}
