import { StoreApi } from "zustand";
import {
  addUrlSchemeIfMissing,
  parseHttpRequestEntry,
  queryParamsToURLString,
  sanitizeEntry,
} from "../../screens/apiClient/utils";
import { ApiClientFeatureContext } from "../../store/apiClientFeatureContext/apiClientFeatureContext.store";
import { AutogeneratedFieldsStore } from "../../store/autogenerateStore";
import { RQAPI } from "../../types";
import { updateRequestWithAuthOptions } from "../auth";
import { cloneDeep } from "lodash";
import { renderVariables as renderVariablesType } from "backend/environment/utils";
import { compile } from "path-to-regexp";

export class HttpRequestPreparationService {
  constructor(
    private ctx: ApiClientFeatureContext,
    private autoGeneratedStore: StoreApi<AutogeneratedFieldsStore>,
    private renderVariables: typeof renderVariablesType
  ) {}

  private renderPathVariables(url: string, pathVariables: RQAPI.PathVariable[]): string {
    const variableValues: Record<RQAPI.PathVariable["key"], RQAPI.PathVariable["value"]> = {};

    if (!pathVariables || pathVariables.length === 0) {
      return url;
    }

    pathVariables.forEach((variable) => {
      variableValues[variable.key] = variable.value;
    });

    const urlObject = new URL(url);

    const toPath = compile(urlObject.pathname);
    const renderedPath = toPath(variableValues);

    urlObject.pathname = renderedPath;

    return urlObject.toString();
  }

  private populateAutogenerateStore(recordId: string) {
    const { getData, getParentChain } = this.ctx.stores.records.getState();
    const apiRecord = getData(recordId);

    if (!apiRecord || !apiRecord.data) {
      return;
    }

    const childDetails = {
      id: apiRecord.id,
      parentId: apiRecord.collectionId,
    };

    const newNamespaces = parseHttpRequestEntry(
      apiRecord.data as RQAPI.HttpApiEntry,
      childDetails,
      getParentChain,
      getData
    );

    this.autoGeneratedStore.getState().initialize(newNamespaces);
  }

  prepareRequest(
    recordId: string,
    entry: RQAPI.HttpApiEntry
  ): {
    renderedVariables: any;
    preparedEntry: RQAPI.HttpApiEntry;
  } {
    const workingEntry = cloneDeep(sanitizeEntry(entry));

    workingEntry.testResults = [];
    workingEntry.request.url = queryParamsToURLString(workingEntry.request.queryParams, workingEntry.request.url);
    workingEntry.request.queryParams = [];

    const { getAllHeaders, getAllQueryParams } = this.autoGeneratedStore.getState();
    const existingHeaders = getAllHeaders();
    const existingQueryParams = getAllQueryParams();

    this.populateAutogenerateStore(recordId);
    const newHeaders = getAllHeaders();
    const newQueryParams = getAllQueryParams();

    const mergedHeaders = new Map();
    existingHeaders.forEach((header) => mergedHeaders.set(header.key, header));
    newHeaders.forEach((header) => mergedHeaders.set(header.key, header));
    const headers = Array.from(mergedHeaders.values()).map((kv, index) => ({ ...kv, id: index, isEnabled: true }));

    const mergedQueryParams = new Map();
    existingQueryParams.forEach((param) => mergedQueryParams.set(param.key, param));
    newQueryParams.forEach((param) => mergedQueryParams.set(param.key, param));
    const queryParams = Array.from(mergedQueryParams.values()).map((kv, index) => ({
      ...kv,
      id: index,
      isEnabled: true,
    }));

    workingEntry.request.headers = updateRequestWithAuthOptions(workingEntry.request.headers, headers);
    workingEntry.request.queryParams = updateRequestWithAuthOptions(workingEntry.request.queryParams, queryParams);

    const { renderedVariables, result: renderedEntry } = this.renderVariables(workingEntry, recordId, this.ctx);
    renderedEntry.request.url = this.renderPathVariables(
      renderedEntry.request.url,
      renderedEntry.request.pathVariables
    );

    renderedEntry.request.url = addUrlSchemeIfMissing(renderedEntry.request.url);

    return {
      renderedVariables,
      preparedEntry: renderedEntry,
    };
  }
}
