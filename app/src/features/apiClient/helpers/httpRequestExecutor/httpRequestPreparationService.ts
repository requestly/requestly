import { StoreApi } from "zustand";
import {
  addUrlSchemeIfMissing,
  queryParamsToURLString,
  sanitizeEntry,
  resolveAuth,
  getPathVariableRegex,
} from "../../screens/apiClient/utils";
import { ApiClientFeatureContext } from "../../store/apiClientFeatureContext/apiClientFeatureContext.store";
import { AutogeneratedFieldsStore, AutogeneratedFieldsNamespace, parseAuth } from "../../store/autogenerateStore";
import { RQAPI } from "../../types";
import { updateRequestWithAuthOptions } from "../auth";
import { cloneDeep, isEmpty } from "lodash";
import { renderVariables as renderVariablesType, renderTemplate } from "backend/environment/utils";
import { compile } from "path-to-regexp";
import { Scope, getScopedVariables, StoreOverrideConfig } from "../variableResolver/variable-resolver";
import { ExecutionContext } from "./scriptExecutionContext";
import { VariableData } from "../../store/variables/types";
import { getApiClientRecordsStore } from "../../commands/store.utils";
import { createDummyVariablesStoreFromData } from "features/apiClient/store/variables/variables.store";
import JSON5 from "json5";
import { RequestContentType } from "../../types";
import { captureException } from "@sentry/react";

export class HttpRequestPreparationService {
  constructor(
    private ctx: ApiClientFeatureContext,
    private autoGeneratedStore: StoreApi<AutogeneratedFieldsStore>,
    private renderVariables: typeof renderVariablesType
  ) {}

  private renderPathVariables(url: string, pathVariables: RQAPI.PathVariable[]): string {
    const variableValues: Record<RQAPI.PathVariable["key"], RQAPI.PathVariable["value"]> = {};

    if (!pathVariables || pathVariables.length === 0) {
      return url;
    }

    pathVariables.forEach((variable) => {
      if (!variable.key) return;
      variableValues[variable.key] = variable.value;
    });

    const normalizedUrl = addUrlSchemeIfMissing(url);

    const urlObject = new URL(normalizedUrl);
    let pathname = urlObject.pathname;

    const variableRegex = getPathVariableRegex(false);

    pathname = pathname.replace(variableRegex, (match, varName, offset, string) => {
      // Ignore colons preceded by alphanumerics (e.g. "f:uuid")
      // We escape it so it passes as the literal text "f:uuid"
      if (offset > 0 && /\w/.test(string[offset - 1])) {
        return `\\:${varName}`;
      }

      return `:"${varName}"`;
    });

    // A try catch is added here to prevent any runtime errors from breaking the request sending flow in case of any issues with path-to-regexp
    try {
      const toPath = compile(pathname);
      const renderedPath = toPath(variableValues);
      urlObject.pathname = renderedPath;
    } catch (error) {
      console.warn("Failed to compile path with variables:", error);
      captureException(error);
    }

    return urlObject.toString();
  }

  /**
   * Converts ExecutionContext to StoreOverrideConfig for use with getScopedVariables
   */
  private buildStoreOverrideFromContext(context: ExecutionContext): StoreOverrideConfig {
    const config: StoreOverrideConfig = {
      runtimeVariablesStore: context.variables ? createDummyVariablesStoreFromData(context.variables) : undefined,
      activeEnvironmentVariablesStore: context.environment
        ? createDummyVariablesStoreFromData(context.environment)
        : undefined,
      globalEnvironmentVariablesStore: context.global ? createDummyVariablesStoreFromData(context.global) : undefined,
      collectionVariablesStore: context.collectionVariables
        ? createDummyVariablesStoreFromData(context.collectionVariables)
        : undefined,
    };

    return config;
  }

  /**
   * Extracts and merges all variables in execution context using getScopedVariables
   */
  private extractVariablesFromContext(
    recordId: string,
    context: ExecutionContext,
    scopes?: Scope[]
  ): Record<string, VariableData> {
    const recordsStore = getApiClientRecordsStore(this.ctx);
    const parents = recordsStore.getState().getParentChain(recordId);

    const storeOverrideConfig = this.buildStoreOverrideFromContext(context);

    const scopedVariables = getScopedVariables(parents, this.ctx.stores, scopes, storeOverrideConfig);

    const variables: Record<string, VariableData> = {};
    for (const [key, [variableData]] of scopedVariables) {
      variables[key] = variableData;
    }

    return variables;
  }

  private updateAuthWithExecutionContext(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    executionContext: ExecutionContext,
    scopes?: Scope[]
  ): void {
    if (!entry.auth) {
      return;
    }

    const recordsStore = getApiClientRecordsStore(this.ctx);
    const getParentChain = recordsStore.getState().getParentChain;
    const getData = recordsStore.getState().getData;

    const record = getData(recordId);

    const childDetails = {
      id: recordId,
      parentId: record?.collectionId ?? "",
    };
    const resolvedAuth = resolveAuth(
      entry.auth,
      childDetails,
      getParentChain,
      getData as (id: string) => RQAPI.ApiClientRecord
    );

    if (!resolvedAuth) {
      return;
    }

    const variables = this.extractVariablesFromContext(recordId, executionContext, scopes);

    const { renderedTemplate: renderedAuth } = renderTemplate(resolvedAuth as any, variables);

    const { headers, queryParams } = parseAuth(renderedAuth as RQAPI.Auth);

    const headersContent = Object.fromEntries(headers);
    const queryParamsContent = queryParams.map(({ key, value }) => ({ key, value }));

    this.autoGeneratedStore
      .getState()
      .purgeAndAdd(AutogeneratedFieldsNamespace.AUTH, headersContent, queryParamsContent);
  }

  /**
   * Renders variables from execution context instead of reading from store
   * Used when we need to use runtime-modified variables (e.g., after pre-request script)
   */
  private renderVariablesFromContext(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    context: ExecutionContext,
    scopes?: Scope[]
  ): { renderedVariables: any; result: RQAPI.HttpApiEntry } {
    const variables = this.extractVariablesFromContext(recordId, context, scopes);
    const { renderedTemplate, renderedVariables } = renderTemplate(entry as any, variables);

    return {
      renderedVariables,
      result: renderedTemplate as RQAPI.HttpApiEntry,
    };
  }

  prepareRequest(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    scopes?: Scope[],
    executionContext?: ExecutionContext
  ): {
    renderedVariables: any;
    preparedEntry: RQAPI.HttpApiEntry;
  } {
    const workingEntry = cloneDeep(sanitizeEntry(entry));

    workingEntry.testResults = [];
    workingEntry.request.url = workingEntry.request.url.split("?")[0];

    // This ensures encoded auth headers (like Basic Auth) are regenerated with updated variables
    if (!isEmpty(executionContext)) {
      this.updateAuthWithExecutionContext(recordId, entry, executionContext, scopes);
    }

    const { getAllHeaders, getAllQueryParams } = this.autoGeneratedStore.getState();

    const headers = getAllHeaders().map((kv, index) => ({ ...kv, id: index, isEnabled: true }));
    const queryParams = getAllQueryParams().map((kv, index) => ({ ...kv, id: index, isEnabled: true }));

    workingEntry.request.headers = updateRequestWithAuthOptions(workingEntry.request.headers, headers);
    workingEntry.request.queryParams = updateRequestWithAuthOptions(workingEntry.request.queryParams, queryParams);

    const { renderedVariables, result } = (() => {
      if (!isEmpty(executionContext)) {
        return this.renderVariablesFromContext(recordId, workingEntry, executionContext, scopes);
      } else {
        return this.renderVariables(workingEntry, recordId, this.ctx, scopes);
      }
    })();

    const renderedEntry = result;

    renderedEntry.request.url = this.renderPathVariables(
      renderedEntry.request.url,
      renderedEntry.request.pathVariables || []
    );
    renderedEntry.request.url = addUrlSchemeIfMissing(renderedEntry.request.url);
    if (
      renderedEntry.request.body &&
      renderedEntry.request.contentType === RequestContentType.JSON &&
      typeof renderedEntry.request.body === "string"
    ) {
      try {
        // Here we are parsing and then re-stringifying to remove any comments and trailing commas from JSON
        const parsed = JSON5.parse(renderedEntry.request.body);
        renderedEntry.request.body = JSON.stringify(parsed);
      } catch (error) {
        // No op - If parsing fails, we leave the body as it is
      }
    }

    // Hacky Fix - When "" or [] is sent along with POST, fetch send content-type=text/plain by default
    // Ideally body should be undefined in db also
    if (!renderedEntry?.request?.body || renderedEntry.request?.body?.length <= 0) {
      renderedEntry.request.body = undefined;
    }

    return {
      renderedVariables,
      preparedEntry: renderedEntry,
    };
  }
}
