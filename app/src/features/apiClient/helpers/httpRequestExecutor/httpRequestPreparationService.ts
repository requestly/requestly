import {
  addUrlSchemeIfMissing,
  queryParamsToURLString,
  sanitizeEntry,
  getPathVariableRegex,
} from "../../screens/apiClient/utils";
import { RQAPI } from "../../types";
import { updateRequestWithAuthOptions } from "../auth";
import { cloneDeep, isEmpty } from "lodash";
import { renderTemplate } from "backend/environment/utils";
import { compile } from "path-to-regexp";
import { Scope, getScopedVariables, StoreOverrideConfig } from "../variableResolver/variable-resolver";
import { ExecutionContext } from "./scriptExecutionContext";
import { ApiClientFeatureContext, selectAncestorIds, selectRecordById } from "features/apiClient/slices";
import { reduxStore } from "store";
import { selectRuntimeVariables } from "features/apiClient/slices/runtimeVariables/selectors";
import { makeAutoGeneratedFieldsSelector } from "features/apiClient/slices/autoGeneratedFields/selectors";
import JSON5 from "json5";
import { RequestContentType } from "../../types";
import { VariableData } from "@requestly/shared/types/entities/apiClient";
import { captureException } from "@sentry/react";

export class HttpRequestPreparationService {
  constructor(private ctx: ApiClientFeatureContext) {}

  private renderPathVariables(url: string, pathVariables: RQAPI.PathVariable[]): string {
    const variableValues: Record<RQAPI.PathVariable["key"], RQAPI.PathVariable["value"]> = {};

    if (!pathVariables || pathVariables.length === 0) {
      return url;
    }

    pathVariables.forEach((variable) => {
      if (!variable.key) return;
      variableValues[variable.key] = variable.value;
    });

    const normalizedUrl = addUrlSchemeIfMissing(url);

    const urlObject = new URL(normalizedUrl);
    let pathname = urlObject.pathname;

    const variableRegex = getPathVariableRegex(false);

    pathname = pathname.replace(variableRegex, (match, varName, offset, string) => {
      // Ignore colons preceded by alphanumerics (e.g. "f:uuid")
      // We escape it so it passes as the literal text "f:uuid"
      if (offset > 0 && /\w/.test(string[offset - 1])) {
        return `\\:${varName}`;
      }

      return `:"${varName}"`;
    });

    // A try catch is added here to prevent any runtime errors from breaking the request sending flow in case of any issues with path-to-regexp
    try {
      const toPath = compile(pathname);
      const renderedPath = toPath(variableValues);
      urlObject.pathname = renderedPath;
    } catch (error) {
      console.warn("Failed to compile path with variables:", error);
      captureException(error);
    }

    return urlObject.toString();
  }

  /**
   * Converts ExecutionContext to StoreOverrideConfig for use with getScopedVariables
   */
  private buildStoreOverrideFromContext(context: ExecutionContext, recordId: string): StoreOverrideConfig {
    const state = this.ctx.store.getState();
    const parents = selectAncestorIds(state, recordId);

    // Build collection variables map - apply execution context's collectionVariables to all collection IDs in hierarchy
    const collectionVariablesMap: Record<string, typeof context.collectionVariables> = {};
    if (context.collectionVariables && Object.keys(context.collectionVariables).length > 0) {
      // Apply to the recordId if it's a collection, and all parent collections
      for (const id of [recordId, ...parents]) {
        const record = selectRecordById(state, id);
        if (record?.type === RQAPI.RecordType.COLLECTION) {
          collectionVariablesMap[id] = context.collectionVariables;
        }
      }
    }

    const config: StoreOverrideConfig = {
      runtimeVariables: context.variables,
      activeEnvironmentVariables: context.environment,
      globalEnvironmentVariables: context.global,
      collectionVariables: Object.keys(collectionVariablesMap).length > 0 ? collectionVariablesMap : undefined,
    };

    return config;
  }

  private getVariables(
    recordId: string,
    config?: {
      storeOverrideConfig?: StoreOverrideConfig;
      scopes?: Scope[];
    }
  ) {
    // Use selector to get runtime variables from global store for consistency
    const runtimeVariables = selectRuntimeVariables(reduxStore.getState());
    const scopedVariables = getScopedVariables(this.ctx.store.getState(), runtimeVariables, recordId, config);
    const variables: Record<string, VariableData> = {};
    for (const key in scopedVariables) {
      const [variableData] = scopedVariables[key]!;
      variables[key] = variableData;
    }
    return {
      scopedVariables,
      variables,
    };
  }

  /**
   * Extracts and merges all variables in execution context using getScopedVariables
   */
  private extractVariablesFromContext(
    recordId: string,
    context: ExecutionContext,
    scopes?: Scope[]
  ): Record<string, VariableData> {
    const storeOverrideConfig = this.buildStoreOverrideFromContext(context, recordId);
    return this.getVariables(recordId, { storeOverrideConfig, scopes }).variables;
  }

  /**
   * Renders variables from execution context instead of reading from store
   * Used when we need to use runtime-modified variables (e.g., after pre-request script)
   */
  private renderVariablesFromContext(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    context: ExecutionContext,
    scopes?: Scope[]
  ): { renderedVariables: any; result: RQAPI.HttpApiEntry } {
    const variables = this.extractVariablesFromContext(recordId, context, scopes);
    const { renderedTemplate, renderedVariables } = renderTemplate(entry as any, variables);

    return {
      renderedVariables,
      result: renderedTemplate as RQAPI.HttpApiEntry,
    };
  }

  private renderVariables(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    scopes?: Scope[]
  ): { renderedVariables: any; result: RQAPI.HttpApiEntry } {
    const { variables } = this.getVariables(recordId, { scopes });
    const { renderedTemplate, renderedVariables } = renderTemplate(entry as any, variables);

    return {
      renderedVariables,
      result: renderedTemplate as RQAPI.HttpApiEntry,
    };
  }

  prepareRequest(
    recordId: string,
    entry: RQAPI.HttpApiEntry,
    scopes?: Scope[],
    executionContext?: ExecutionContext
  ): {
    renderedVariables: any;
    preparedEntry: RQAPI.HttpApiEntry;
  } {
    const workingEntry = cloneDeep(sanitizeEntry(entry));

    workingEntry.testResults = [];
    workingEntry.request.url = queryParamsToURLString(workingEntry.request.queryParams, workingEntry.request.url);
    workingEntry.request.queryParams = [];

    const { scopedVariables } = this.getVariables(recordId, {
      storeOverrideConfig: executionContext
        ? this.buildStoreOverrideFromContext(executionContext, recordId)
        : undefined,
      scopes,
    });
    const selector = makeAutoGeneratedFieldsSelector(recordId, scopedVariables, workingEntry);
    const { headers: autoGeneratedHeaders, queryParams: autoGeneratedQueryParams } = selector(
      this.ctx.store.getState()
    );

    workingEntry.request.headers = updateRequestWithAuthOptions(workingEntry.request.headers, autoGeneratedHeaders);
    workingEntry.request.queryParams = updateRequestWithAuthOptions(
      workingEntry.request.queryParams,
      autoGeneratedQueryParams
    );

    const { renderedVariables, result } = (() => {
      if (!isEmpty(executionContext)) {
        return this.renderVariablesFromContext(recordId, workingEntry, executionContext, scopes);
      } else {
        return this.renderVariables(recordId, workingEntry, scopes);
      }
    })();

    const renderedEntry = result;

    renderedEntry.request.url = this.renderPathVariables(
      renderedEntry.request.url,
      renderedEntry.request.pathVariables || []
    );
    renderedEntry.request.url = addUrlSchemeIfMissing(renderedEntry.request.url);
    if (
      renderedEntry.request.body &&
      renderedEntry.request.contentType === RequestContentType.JSON &&
      typeof renderedEntry.request.body === "string"
    ) {
      try {
        // Here we are parsing and then re-stringifying to remove any comments and trailing commas from JSON
        const parsed = JSON5.parse(renderedEntry.request.body);
        renderedEntry.request.body = JSON.stringify(parsed);
      } catch (error) {
        // No op - If parsing fails, we leave the body as it is
      }
    }

    // Hacky Fix - When "" or [] is sent along with POST, fetch send content-type=text/plain by default
    // Ideally body should be undefined in db also
    if (!renderedEntry?.request?.body || renderedEntry.request?.body?.length <= 0) {
      renderedEntry.request.body = undefined;
    }

    return {
      renderedVariables,
      preparedEntry: renderedEntry,
    };
  }
}
