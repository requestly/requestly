import { createSelector } from "@reduxjs/toolkit";
import lodash from "lodash";
import { useMemo } from "react";
import { selectAncestorRecords, selectRecordById } from "../apiRecords";
import { ApiClientStoreState } from "../workspaceView/helpers/ApiClientContextRegistry";
import { Authorization } from "features/apiClient/screens/apiClient/components/views/components/request/components/AuthorizationView/types/AuthConfig";
import { useApiClientSelector } from "../hooks/base.hooks";
import { ScopedVariables, useScopedVariables } from "features/apiClient/helpers/variableResolver/variable-resolver";
import { renderTemplate } from "backend/environment/utils";
import { RequestContentType, RQAPI } from "features/apiClient/types";
import { extractAuthHeadersAndParams } from "features/apiClient/helpers/auth";
import { isGraphQLApiEntry } from "features/apiClient/screens/apiClient/utils";
import { createHeaderEntry } from "features/apiClient/store/autogenerateStore";
import { CONTENT_TYPE_HEADER } from "features/apiClient/constants";
import { GraphQLRecordEntity, HttpRecordEntity } from "../entities";
import { BufferedApiClientEntity } from "../entities/buffered/factory";

function makeAuthChainSelector(id: string) {
  const selector = createSelector(
    [
      (state: ApiClientStoreState) => ({
        self: selectRecordById(state, id),
        parents: selectAncestorRecords(state, id),
      }),
    ],
    ({ self, parents }) => {
      if (!self) {
        return parents.map((p) => p.data.auth);
      }
      return [self, ...parents].map((p) => p.data.auth);
    }
  );

  return selector;
}

export function makeAuthResolverSelector(id: string) {
  const selector = createSelector([makeAuthChainSelector(id)], (authChain) => {
    for (const auth of authChain) {
      if (auth.currentAuthType !== Authorization.Type.INHERIT) {
        return auth as RQAPI.Auth & { currentAuthType: Exclude<Authorization.Type, Authorization.Type.INHERIT> };
      }
    }

    return {
      currentAuthType: Authorization.Type.NO_AUTH,
      authConfigStore: {},
    } as RQAPI.Auth;
  });

  return selector;
}

function makeFilledAuthSelector(id: string, scopedVariables: ScopedVariables) {
  const selector = createSelector([makeAuthResolverSelector(id)], (auth) => {
    if (auth.currentAuthType === Authorization.Type.NO_AUTH) {
      return auth;
    }
    const { renderedTemplate } = renderTemplate(
      auth as any,
      lodash.mapValues(scopedVariables, ([v]) => v)
    );
    return renderedTemplate as RQAPI.Auth;
  });

  return selector;
}

function resolveAuthFromEntry(
  entryAuth: RQAPI.Auth,
  parentAuths: RQAPI.Auth[]
): RQAPI.Auth & { currentAuthType: Exclude<Authorization.Type, Authorization.Type.INHERIT> } {
  const authChain = [entryAuth, ...parentAuths];

  for (const auth of authChain) {
    if (auth?.currentAuthType !== Authorization.Type.INHERIT) {
      return auth as RQAPI.Auth & { currentAuthType: Exclude<Authorization.Type, Authorization.Type.INHERIT> };
    }
  }

  return {
    currentAuthType: Authorization.Type.NO_AUTH,
    authConfigStore: {},
  } as RQAPI.Auth & { currentAuthType: Authorization.Type.NO_AUTH };
}

export function makeAutoGeneratedFieldsSelector(id: string, scopedVariables: ScopedVariables, entry: RQAPI.ApiEntry) {
  return (state: ApiClientStoreState) => {
    const parentAuths = selectAncestorRecords(state, id).map((p) => p.data.auth);

    const resolvedAuth = resolveAuthFromEntry(entry.auth, parentAuths);

    let filledAuth = resolvedAuth;
    if (resolvedAuth.currentAuthType !== Authorization.Type.NO_AUTH) {
      const { renderedTemplate } = renderTemplate(
        resolvedAuth as any,
        lodash.mapValues(scopedVariables, ([v]) => v)
      );
      filledAuth = renderedTemplate as typeof resolvedAuth;
    }

    const result = extractAuthHeadersAndParams(filledAuth);

    const contentTypeHeader = (() => {
      if (isGraphQLApiEntry(entry)) {
        return createHeaderEntry(CONTENT_TYPE_HEADER, RequestContentType.JSON);
      }
      if (entry.request.body && entry.request.body.length > 0 && entry.request.contentType) {
        return createHeaderEntry(CONTENT_TYPE_HEADER, entry.request.contentType);
      }
    })();

    if (contentTypeHeader) {
      result.headers.push({
        id: result.headers.length + 1,
        isEnabled: true,
        key: CONTENT_TYPE_HEADER,
        value: contentTypeHeader.value,
      });
    }

    return result;
  };
}

export function useAutoGeneratedFields(entity: HttpRecordEntity | GraphQLRecordEntity) {
  const id = useMemo(() => {
    const referenceId = (entity as unknown as BufferedApiClientEntity).meta.referenceId;
    return referenceId || entity.id;
  }, [entity]);

  const scopedVariables = useScopedVariables(id);

  return useApiClientSelector(
    useMemo(
      () => (state: ApiClientStoreState) => {
        const entry = entity.getEntityFromState(state).data;
        const selector = makeAutoGeneratedFieldsSelector(id, scopedVariables, entry);
        return selector(state);
      },
      [id, scopedVariables, entity]
    )
  );
}
